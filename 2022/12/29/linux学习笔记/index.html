

  <!DOCTYPE html>
  <html lang="en">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="description" content=欢迎访问！ >
  <meta name="keywords" content=hexo,theme,MiHoYo >

  <head>
    <title>
      linux学习笔记 [ Hexo ]
    </title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>

    <link rel="stylesheet" href="/css/header.css">
<div class="header">
  <div class="logo">
    <span class="pull-left">
      <a id="site-name" href="/">
        Zhangyj&#39;s blog
      </a>
    </span>
  </div>
  <ul class="nav-list">
    
      <li>
        <a href="/">
          首页
        </a>
      </li>
      
      <li>
        <a href="/about">
          关于
        </a>
      </li>
      
  </ul>
</div>

      <!--<link rel="stylesheet" href="/css/top-header.css">
<div id="top-bar" class="fixed">

  <a class="goto-top" href="#"></a>
  <ul class="bar-list bar-list-1">
    
      <li>
        <p>
          <a href="/">
            <text class="bar-text bar-p1">
              首页
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
      <li>
        <p>
          <a href="/about">
            <text class="bar-text bar-p1">
              关于
            </text>
            <text class="bar-text bar-p2"></text>
          </a>
          <text class="bar-p3">/</text>
        </p>
      </li>
      
  </ul>
</div>-->

        <div id="content-outer">
          <div class="content-inner">
            <link rel="stylesheet" href="/css/post.css">
<div class="posts">
  <a href="/index.html"><i class="fa fa-home
replay-btn" aria-hidden="true"></i></a>
  <div class="post-title">
    <p>
      linux学习笔记
    </p>
    <hr>
  </div>
  <div class="post-content">
    <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><blockquote>
</blockquote>
<p>以下笔记是本人基于这学期的Linux课程，自己归纳整理的关于Linux方面的笔记，仅供参考。读者若发现错误，可私信我，我会及时改正。</p>
<blockquote>
</blockquote>
<h1 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h1><h2 id="1-1、共享文件夹-vmtools"><a href="#1-1、共享文件夹-vmtools" class="headerlink" title="1.1、共享文件夹 - vmtools"></a>1.1、共享文件夹 - vmtools</h2><ol>
<li><p>可以通过vmtools这个工具实现：</p>
<ul>
<li>可以直接粘贴命令在Windows和Linux之间</li>
<li>可以设置Windows和Linux的共享文件夹</li>
</ul>
</li>
<li><p><strong>安装</strong></p>
<ul>
<li><p>点击 VMwareStation 上的虚拟机 -&gt; install vmware tools</p>
</li>
<li><p>centos 会有一个安装包，将其中的压缩文件解压就会得到一个安装文件</p>
<p><code>解压命令：tar -zxvf xxx.tar.gz</code></p>
<p><strong>注意：如果要将压缩包复制到别的目录下，要注意权限问题，一般用root账户登录就能避免</strong></p>
</li>
<li><p>进入解压的目录，安装 <code>./vmware-install.pl</code></p>
</li>
<li><p>全部使用默认设置即可</p>
</li>
<li><p>需要重启系统</p>
</li>
</ul>
</li>
<li><p><strong>设置共享文件夹</strong></p>
<ul>
<li>在实际的开发中，文件的上传和下载是用远程方式操作的</li>
<li>Windows端：虚拟机 -&gt; 设置 -&gt; 选项 -&gt; 共享文件夹 -&gt; 总是启用 -&gt; 添加Windows的文件夹路径</li>
<li>Linux端：根目录下的mnt -&gt; hgfs -&gt; 这里就是共享的文件夹</li>
</ul>
</li>
</ol>
<h1 id="2、Linux目录结构"><a href="#2、Linux目录结构" class="headerlink" title="2、Linux目录结构"></a>2、Linux目录结构</h1><h2 id="2-1、基本介绍"><a href="#2-1、基本介绍" class="headerlink" title="2.1、基本介绍"></a>2.1、基本介绍</h2><ul>
<li>Linux中，<code>/</code>即代表根目录，不同于Windows的C、D、E盘结构，Linux只有一个根目录，然后在此目录下创建其他目录，是<strong>树结构</strong></li>
<li>Linux的文件系统采用级层式的树状目录结构，最上层目录就是根目录，有且只有一个</li>
<li>&#x3D;&#x3D;Linux世界里，一切皆为文件&#x3D;&#x3D;，即使是硬件，也会被映射成相应的文件</li>
<li>&#x3D;&#x3D;<strong>Linux开机流程</strong>：开机 &#x3D;&gt; BIOS &#x3D;&gt; &#x2F;boot &#x3D;&gt; init进程 &#x3D;&gt; 运行级别 &#x3D;&gt; 运行级别对应的服务&#x3D;&#x3D;</li>
</ul>
<h2 id="2-2、根目录"><a href="#2-2、根目录" class="headerlink" title="2.2、根目录"></a>2.2、根目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/bin   这个目录存放着最经常使用的命令，主要有cat、chmod、chown、date、mv、mkdir、cp、bash等</span><br><span class="line"></span><br><span class="line">/sbin   存放着系统管理员使用的系统管理程序，包括开机过程所需要的开机、修复、还原系统所需要的命令</span><br><span class="line"></span><br><span class="line">/home  存放普通用户的主目录，每个用户都有一个自己的目录，一般目录名以用户账号命名，主文件夹有两种代号：～代表当前这个用户的主文件夹</span><br><span class="line"></span><br><span class="line">/root   超级权限者的用户主目录，系统管理员的主文件夹</span><br><span class="line"></span><br><span class="line">/lib  放置的是系统开机所需要最基本的动态链接共享库，类似于Windows的DLL文件，包括开机时会用到的数据库，以及在/bin和/sbin下命令会调用的函数库</span><br><span class="line"></span><br><span class="line">/lost+found  一般情况下是空的，系统非法关机后，系统就会存放一些文件</span><br><span class="line"></span><br><span class="line">/etc   所有系统管理员所需要的配置文件和子目录，例如人员的帐号密码文件，各种服务的起始文件等。一般来说，这个目录下面的各文件属性时可以让一般的用户查阅的，但是只有root用户有权先修改。FHS建议不要放置可执行的文件在这个目录下</span><br><span class="line"></span><br><span class="line">/usr  这里面放置的数据属于可分享的与不可变动的（shareable，static），其实usr是UNIX SOFTWARE RESOURCE的缩写，而非user的缩写，也就是unix操作系统软件放置的位置而非用户的数据</span><br><span class="line"></span><br><span class="line">/boot  这个目录主要放置开机能够使用到的文件，包括linux内核文件和开机菜单与开机所以需要的配置文件</span><br><span class="line">====================================================================================================</span><br><span class="line">一下三个目录跟Linux内核有关，一般不要动</span><br><span class="line">/proc  这个目录本身是一个虚拟文件系统，它放置的数据都是在内存当中，不占用硬盘的容量</span><br><span class="line"></span><br><span class="line">/src  src可以视作service的缩写，是一些网络服务启动后，这些服务需要取用的数据目录，常见的服务例如www,ftp等</span><br><span class="line"></span><br><span class="line">/sys  这个目录其实跟/proc非常的相似，也是一个虚拟的文件系统主要也是记录与内核相关的信息，不占用硬盘容量</span><br><span class="line">====================================================================================================</span><br><span class="line">/tmp  这是让一般的用户或者是正在执行的程序暂时放置文件的地方</span><br><span class="line"></span><br><span class="line">/dev   在linux中任何的设备和接口设备都是以文件的形式存在于这个目录当中。你只要到通过访问这个目录下的某个文件就相当于访问某个设备，类似于Windows的设备管理器</span><br><span class="line"></span><br><span class="line">/media  放置的就是可以删除的设备。包括软盘，光盘，dvd等都临时挂放在此。</span><br><span class="line"></span><br><span class="line">/mnt  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在该目录下，然后进入该目录就能看见了，例如vmtools的共享文件夹</span><br><span class="line"></span><br><span class="line">/opt  这个是给第三方软件放置的目录。不过，在以前的linux下我们喜欢放置在/usr/local下面，一般是通过编译源码方式安装的程序。</span><br><span class="line"></span><br><span class="line">/var  这个目录下面主要放置常态性变动的文件，包括cache,logfile以及某些软夹运营所产生的文件。例如MYSQL数据库文件等</span><br><span class="line"></span><br><span class="line">/selinux SeLinux是一种安全子系统他能控制程序只能访问特定文件</span><br></pre></td></tr></table></figure>

<h2 id="2-3、小结"><a href="#2-3、小结" class="headerlink" title="2.3、小结"></a>2.3、小结</h2><ul>
<li>Linux有且只有一个根目录</li>
<li>Linux的各个目录存放的内容是预先规划好的，不要乱放文件</li>
<li>Linux是以文件的形式来管理设备，因此Linux中一切皆为文件</li>
<li>Linux的各个文件目录下存放什么内容必须有一个认识，最好能指哪个说哪个</li>
<li>学习后脑子里应该有一颗目录树</li>
</ul>
<h1 id="3、远程登录到Linux服务器"><a href="#3、远程登录到Linux服务器" class="headerlink" title="3、远程登录到Linux服务器"></a>3、远程登录到Linux服务器</h1><h2 id="3-1、为什么要远程登陆呢？"><a href="#3-1、为什么要远程登陆呢？" class="headerlink" title="3.1、为什么要远程登陆呢？"></a>3.1、为什么要远程登陆呢？</h2><ol>
<li>如果是实际的开发，Linux服务器一般是在第三方服务商的机房里，那么要控制Linux服务器，就要同构远程登陆的方式来操作</li>
<li>还有文件的上传和下载，也要通过远程登录的方式</li>
<li>可以用termius &#x2F; XShell 远程登陆 &#x2F; Xftp 远程文件上传下载</li>
<li>安装之前要先开启Linux的远程监听服务，然后开启服务来供远程终端连接，一般云服务器会用一个密钥来连接，<strong>该服务监听22号端口</strong></li>
<li><code>setup -&gt; 系统服务 -&gt; sshd</code> 查看是否开启远程监听服务（SSHD），<code>*</code> 代表已经开启；<code>service sshd status</code> 也可以检查</li>
</ol>
<h2 id="3-2、连接Linux"><a href="#3-2、连接Linux" class="headerlink" title="3.2、连接Linux"></a>3.2、连接Linux</h2><ol>
<li><p>通过XShell连接到Linux服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig    查看IP地址</span><br></pre></td></tr></table></figure>

<p><strong>默认nat模式下，linux的IP与虚拟的网卡IP不一样，要设置端口转发，才能确保正常连接！</strong></p>
</li>
<li><p><strong>Linux虚拟机的三种网络连接形式</strong></p>
<ul>
<li>桥接模式：与主机在同一网段，Linux可以和其他系统通信，但是如果Linux虚拟机数量多可能造成ip冲突</li>
<li>NAT模式：网络地址转换方式，即母机代理通讯，再创建子网供虚拟机使用，其中一个和Linux无法和本局域网中的其他真实主机进行通讯</li>
<li>仅主机模式：即单机模式，是一个独立的主机，不能访问外网</li>
</ul>
<p>&#x3D;&#x3D;一般选择NAT模式&#x3D;&#x3D;</p>
</li>
</ol>
<h2 id="3-3、远程下载和上传文件"><a href="#3-3、远程下载和上传文件" class="headerlink" title="3.3、远程下载和上传文件"></a>3.3、远程下载和上传文件</h2><p>可以使用Xftp软件进行文件的传输，直接安装即可，然后输入Linux主机的IP地址，选择SFTP协议（22号端口），再输入账号密码即可</p>
<p>如果出现中文乱码问题，可以在主机的属性中的选项中选择使用<strong>UTF-8编码</strong>即可</p>
<p>直接拖拉文件即可</p>
<h1 id="4、Vi和Vim编辑器"><a href="#4、Vi和Vim编辑器" class="headerlink" title="4、Vi和Vim编辑器"></a>4、Vi和Vim编辑器</h1><h2 id="4-1、基本介绍"><a href="#4-1、基本介绍" class="headerlink" title="4.1、基本介绍"></a>4.1、基本介绍</h2><ol>
<li>所有Linux系统都会内建vi文本编辑器</li>
<li>Vim具有程序编辑的能力，可以当作是vi的增强版，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等方便编程的功能特别丰富，被广泛使用。</li>
</ol>
<h2 id="4-2、vi和vim的三种常见模式"><a href="#4-2、vi和vim的三种常见模式" class="headerlink" title="4.2、vi和vim的三种常见模式"></a>4.2、vi和vim的三种常见模式</h2><ol>
<li><p>正常模式</p>
<p><strong>一般默认就是正常模式</strong>，在该模式下，我们<strong>可以使用快捷键</strong>。</p>
<p>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。</p>
</li>
<li><p>插入模式（编辑模式）</p>
<p>在模式下，程序员可以<strong>输入内容</strong>。</p>
<p>按下<code> i, I, o, O, a, A, r, R</code> 等任何一个字母之后才会进入编辑模式, <strong>一般来说按<code>i</code>即可</strong></p>
</li>
<li><p>命令行模式</p>
<p>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中操作的</p>
</li>
</ol>
<h2 id="4-3、快速入门案例"><a href="#4-3、快速入门案例" class="headerlink" title="4.3、快速入门案例"></a>4.3、快速入门案例</h2><ul>
<li>写一个hello world的 java 代码文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ll  查看目录下的文件</span><br><span class="line">vim Hello.java  用vim打开一个java文件</span><br><span class="line">输入 i 进入编辑模式</span><br><span class="line">输入代码:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输入完成后按ESC按键，从编辑模式切换到正常模式</span><br><span class="line">输入 :或者/ 后即可从正常模式切换到命令行模式</span><br><span class="line">输入 wq (w是写入的意思 q是退出的意思) 保存 </span><br><span class="line">    q 是退出，如果有修改，就会提示加上 ! 强制执行，这样修改的内容就会消失</span><br></pre></td></tr></table></figure>

<h2 id="4-4、快捷键使用案例"><a href="#4-4、快捷键使用案例" class="headerlink" title="4.4、快捷键使用案例"></a>4.4、快捷键使用案例</h2><blockquote>
<p>要先从进入正常模式才可以使用快捷键</p>
</blockquote>
<ol>
<li><strong>拷贝当前行</strong> <code>yy</code> , 拷贝当前行向下的 5 行 <code>5yy</code>，并粘贴  <code>p</code> </li>
<li><strong>删除当前行</strong> <code>dd</code> , 删除当前行向下的 5 行 <code>5dd</code></li>
<li>在文件中查<strong>找某个单词</strong>：命令行下 <code>/</code> 关键字 ， 回车 查找 , 输入 <code>n</code> 就是查找下一个</li>
<li>设<strong>置文件的行号</strong>，<strong>取消文件的行号</strong>：命令行下<code>:set nu</code> 和 <code>:set nonu</code></li>
<li>编辑 &#x2F;etc&#x2F;profile 文件，使用快捷键到底文档的<strong>最末行</strong><code>G</code>和<strong>最首行</strong><code>gg</code>，注意这些都是在&#x3D;&#x3D;正常模式&#x3D;&#x3D;下执行的</li>
<li>在一个文件中输入 “hello” ,然后又<strong>撤销这个动作</strong>，在正常模式下输入 <code>u</code></li>
<li><strong>取消着色标记</strong>操作是  <code>:noh</code></li>
<li>编辑 &#x2F;etc&#x2F;profile 文件，并将<strong>光标移动到 第 20 行</strong> <code>shift+g</code></li>
</ol>
<ul>
<li>第一步：显示行号 :set nu <ul>
<li>输入20，直接按回车的话，是从当前位置前进20行</li>
<li>数字+Enter 可以到 光标当前位置+数字 的那一行</li>
</ul>
</li>
<li>第二步：输入 20 这个数</li>
<li>第三步: 输入 shift+g</li>
</ul>
<ol start="9">
<li>单行注释 <code># 后面写注释</code></li>
<li>多行注释：<code>:&lt;&lt;!   中间的代码   !</code></li>
</ol>
<h2 id="4-5、vim键盘图"><a href="#4-5、vim键盘图" class="headerlink" title="4.5、vim键盘图"></a>4.5、vim键盘图</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch1.gif"></p>
<p><img src="https://www.linuxidc.com/upload/2016_08/160826064815403.png"></p>
<h1 id="5、开机、重启和用户登录注销"><a href="#5、开机、重启和用户登录注销" class="headerlink" title="5、开机、重启和用户登录注销"></a>5、开机、重启和用户登录注销</h1><h2 id="5-1、关机和重启"><a href="#5-1、关机和重启" class="headerlink" title="5.1、关机和重启"></a>5.1、关机和重启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line">	shutdown -h now 立即关机</span><br><span class="line">	shutdown -h 1 表示一分钟过后就关机</span><br><span class="line">	shutdown -r now 立即重启</span><br><span class="line">halt 停机指令 直接使用即可 效果等同于关机</span><br><span class="line">reboot 就是重启系统</span><br><span class="line">sync 代表把内存的数据同步到磁盘上</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不管是重启还是关机，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失</strong></li>
</ul>
<h2 id="5-2、用户登录和注销"><a href="#5-2、用户登录和注销" class="headerlink" title="5.2、用户登录和注销"></a>5.2、用户登录和注销</h2><ul>
<li>登录时<strong>尽量少用 root 帐号登录</strong>，因为它是系统管理员，拥有最大的权限，<strong>避免操作失误</strong>。可以利用普通用户登录，登录后再用<code>su - 用户名</code> 命令来切换成系统管理员身份</li>
<li>在提示符下输入<code>logout</code>即可注销用户</li>
</ul>
<blockquote>
<p>logout 注销指令在图形运行级别无效即在虚拟机上操作时无效，在 运行级别 3 下有效，例如远程连接时使用</p>
</blockquote>
<h1 id="6、用户管理"><a href="#6、用户管理" class="headerlink" title="6、用户管理"></a>6、用户管理</h1><h2 id="6-1、基本介绍"><a href="#6-1、基本介绍" class="headerlink" title="6.1、基本介绍"></a>6.1、基本介绍</h2><ul>
<li>Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</li>
<li>用户组：Linux下有很多地用户组，这是Linux对用户管理地一种管理，每一个用户至少属于一个组，例如 root 用户属于 root 组</li>
<li>家目录：<code>/home/</code> 目录下有各个创建的用户对应的家目录，当用户登录时会自动地进入到自己地家目录</li>
</ul>
<h2 id="6-2、添加用户"><a href="#6-2、添加用户" class="headerlink" title="6.2、添加用户"></a>6.2、添加用户</h2><ul>
<li><p>基本语法：<code>useradd [选项] 用户名</code></p>
</li>
<li><p>例如：添加用户小明 &#x3D;&#x3D;&gt; 添加完成后发生的变化：</p>
<ul>
<li>有一个组被创建了(系统会默认创建一个<strong>同名用户组</strong>，当然也可以指定加入一个组)； </li>
<li><code>/home/</code> 目录下有一个 <code>xiaoming</code> 的目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd xiaoming</span><br><span class="line">useradd -d /home/tiger xiaohong    给新创建的用户xiaohong指定家目录所在位置</span><br><span class="line">useradd -g groupname username   将新创建的用户添加到指定用户组</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3、给用户指定-x2F-修改密码"><a href="#6-3、给用户指定-x2F-修改密码" class="headerlink" title="6.3、给用户指定&#x2F;修改密码"></a>6.3、给用户指定&#x2F;修改密码</h2><p>使用命令 <code>passwd 用户名</code> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">passwd [-k] [-l] [-u [-f]] [-d] [-S] [username]</span><br><span class="line">-d 删除密码</span><br><span class="line">-f 强制执行</span><br><span class="line">-k 更新只能发送在过期之后</span><br><span class="line">-l 停止账号使用</span><br><span class="line">-S 显示密码信息</span><br><span class="line">-u 启用已被停止的账户</span><br><span class="line">-x 设置密码的有效期</span><br><span class="line">-g 修改群组密码</span><br><span class="line">-i 过期后停止用户账号</span><br></pre></td></tr></table></figure>

<h2 id="6-4、删除用户"><a href="#6-4、删除用户" class="headerlink" title="6.4、删除用户"></a>6.4、删除用户</h2><p>使用命令<code>userdel username</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel xiaoming   删除用户 xiaoming 但是要保留家目录</span><br><span class="line">userdel -r xiaoming    删除用户 xiaoming 以及用户主目录</span><br></pre></td></tr></table></figure>

<ul>
<li>实际开发工作中，删除用户时一般不会将家目录删除，以免一些文件被误删</li>
</ul>
<h2 id="6-5、查询用户"><a href="#6-5、查询用户" class="headerlink" title="6.5、查询用户"></a>6.5、查询用户</h2><p>使用命令 <code>id username</code></p>
<p>系统会显示：<strong>用户id号；所在组id号；组名</strong></p>
<p>如果不存在该用户，会显示 <strong>无此用户</strong></p>
<h2 id="6-6、切换用户"><a href="#6-6、切换用户" class="headerlink" title="6.6、切换用户"></a>6.6、切换用户</h2><ul>
<li>在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root</li>
<li>使用命令：<code>切换：su - username  返回原来的用户：exit</code></li>
<li><strong>高权限用户切换到低权限用户时不需要输入密码，反之需要</strong></li>
</ul>
<h2 id="6-7、用户组"><a href="#6-7、用户组" class="headerlink" title="6.7、用户组"></a>6.7、用户组</h2><ul>
<li>用户组：类似于角色，系统可以对有共性的多个用户进行统一的管理</li>
<li>增加组： <code>groupadd groupname</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd -g groupname username   将新创建的用户添加到指定用户组</span><br><span class="line">usermod -g groupname username   修改某个用户的用户组</span><br><span class="line">usermod -d 目录名 用户名         改变该用户登录的初始目录</span><br></pre></td></tr></table></figure>

<h2 id="6-8、用户和组的相关文件"><a href="#6-8、用户和组的相关文件" class="headerlink" title="6.8、用户和组的相关文件"></a>6.8、用户和组的相关文件</h2><h3 id="6-8-1、-x2F-etc-x2F-passwd-文件"><a href="#6-8-1、-x2F-etc-x2F-passwd-文件" class="headerlink" title="6.8.1、&#x2F;etc&#x2F;passwd 文件"></a>6.8.1、&#x2F;etc&#x2F;passwd 文件</h3><ul>
<li>用户（user）的配置文件，<strong>记录用户的各种信息</strong></li>
<li>每行的含义：<code>用户名:密码:用户id:组id:注释性描述::家目录:登录 Shell</code></li>
</ul>
<h3 id="6-8-2、-x2F-etc-x2F-group-文件"><a href="#6-8-2、-x2F-etc-x2F-group-文件" class="headerlink" title="6.8.2、&#x2F;etc&#x2F;group 文件"></a>6.8.2、&#x2F;etc&#x2F;group 文件</h3><ul>
<li>组(group)的配置文件，<strong>记录 Linux 包含的组的信息</strong></li>
<li>每行含义：<code>组名:口令:组标识号:组内用户列表</code></li>
</ul>
<h3 id="6-8-3、-x2F-etc-x2F-shadow-文件"><a href="#6-8-3、-x2F-etc-x2F-shadow-文件" class="headerlink" title="6.8.3、&#x2F;etc&#x2F;shadow 文件"></a>6.8.3、&#x2F;etc&#x2F;shadow 文件</h3><ul>
<li><p>口令的配置文件（密码和登录信息，是加密的）</p>
</li>
<li><p>每行的含义：</p>
<p><code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></p>
</li>
</ul>
<h1 id="7、实用指令"><a href="#7、实用指令" class="headerlink" title="7、实用指令"></a>7、实用指令</h1><h2 id="7-1、指定运行级别"><a href="#7-1、指定运行级别" class="headerlink" title="7.1、指定运行级别"></a>7.1、指定运行级别</h2><ul>
<li><p><strong>七大运行级别</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0 ：关机</span><br><span class="line">1 ：单用户【找回丢失密码】</span><br><span class="line">2：多用户状态没有网络服务</span><br><span class="line">3：多用户状态有网络服务</span><br><span class="line">4：系统未使用保留给用户 一般不使用</span><br><span class="line">5：图形界面</span><br><span class="line">6：系统重启</span><br><span class="line">常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件</span><br><span class="line">系统的运行级别配置文件 /etc/inittab</span><br><span class="line">/etc/inittab 中的 id:5:initdefault: 这一行中的数字就代表着当前运行级别</span><br><span class="line">切换运行级别 init [0|1|2|3|5|6]</span><br><span class="line">也可以编辑文件中的那一行，然后reboot即可</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>systemctl get-default</code> 查看当前运行级别</p>
</li>
<li><p>centos7中，这个文件在<code>/lib/systemd/system</code></p>
</li>
<li><p>找回root用户的密码：可以进入单用户模式之后再使用passwd命令修改</p>
</li>
</ul>
<h2 id="7-2、帮助指令"><a href="#7-2、帮助指令" class="headerlink" title="7.2、帮助指令"></a>7.2、帮助指令</h2><p>当我们对某个指令不熟悉的时候，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法</p>
<ol>
<li>通过man指令获得帮助信息：<code>man [命令或配置文件]</code></li>
<li>通过help指令获得 shell 内置命令的帮助信息：<code>help [命令]</code></li>
<li>当然，更推荐直接百度</li>
</ol>
<blockquote>
<p>按J或K滚动翻看</p>
</blockquote>
<h2 id="7-3、文件目录类指令"><a href="#7-3、文件目录类指令" class="headerlink" title="7.3、文件目录类指令"></a>7.3、文件目录类指令</h2><blockquote>
<p>斜杠在前表示绝对路径，没有斜杠表示相对路径，斜杠在后表示某文件夹下的一个文件</p>
</blockquote>
<ol>
<li><p><strong>pwd 命令</strong>( print woking dictionary )，显示当前工作目录的绝对路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：pwd</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ls 命令</strong> ，显示当前目录的所有文件和目录，包括隐藏的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用方法：ls [选项] [目录或是文件]</span><br><span class="line">-a 显示当前目录所有的文件和目录，包括隐藏的</span><br><span class="line">-l 以列表的方式显示信息</span><br><span class="line">-h 显示文件大小</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cd 命令</strong>（change directory），切换到指定的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd [绝对路径|相对路径]</span><br><span class="line">cd~ 或者 cd: 回到自己家目录</span><br><span class="line">cd .. 回到当前目录的上一级目录</span><br><span class="line">. 代表当前目录</span><br><span class="line">.. 代表上一级目录</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mkdir 命令</strong>（make directory），用于创建目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] 要创建的目录</span><br><span class="line">-p 创建多级目录，多级目录即创建一个目录后然后在这个目录下再创建一个目录，相当于创建两个目录</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rmdir 命令</strong>（remove directory），用于删除&#x3D;&#x3D;空目录&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项] 要删除的空目录</span><br><span class="line">rm -rf 要删除的非空目录</span><br><span class="line">注意！rm -rf /* 是删除根目录下的所有内容，不要乱听别人说</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>touch 命令</strong>，用于创建空文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名称</span><br><span class="line">也可以一次创建多个文件，空格分开即可</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cp 命令</strong>（copy），拷贝文件到指定目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp [选项] 要拷贝的文件 要粘贴的目录</span><br><span class="line">-r  递归复制整个文件夹</span><br><span class="line">例1：cp a.txt /home/b/ 将a.txt文件拷贝到/home/b目录下</span><br><span class="line">例2：cp -r /home/a/ /home/b/ 将/home/a/目录下的所有文件递归拷贝到/home/b/下，当有重复文件的时候会提示是否覆盖</span><br><span class="line">例3：cp -r /home/a/ /home/b/ 这样就能强制覆盖系统不会提示，这样就不用一个一个文件的操作</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rm 命令</strong>，删除文件或目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 要删除的文件或目录</span><br><span class="line">-r  递归删除整个文件夹</span><br><span class="line">-f  强制删除不提示</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mv 命令</strong>，移动文件与目录，或重命名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv 旧文件名 新文件名     重命名</span><br><span class="line">mv 源文件路径 目标文件路径   移动文件</span><br><span class="line">例1：mv a.txt b.txt</span><br><span class="line">例2：mv a.txt /home/    如果移动到的文件夹内存在同名的文件会提示是否覆盖,也可以重命名</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cat 命令</strong>，查看文件内容，以只读的方式打开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] 要查看的文件</span><br><span class="line">-n ：显示行号</span><br><span class="line">例1：cat -n /etc/profile 这样直接打开文件会一下走到最后一行然后退出到命令行</span><br><span class="line">	因此一般会加上 | more 来分页显示</span><br><span class="line">cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more</span><br><span class="line">cat 文件名 | more [分页浏览]</span><br><span class="line">回车翻页</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>more 命令</strong></p>
<p>more 指令是一个基于 VI 编辑器的文本过滤器，它以&#x3D;&#x3D;全屏幕的方式按页显示文本文件的内容&#x3D;&#x3D;</p>
<p>more 指令中内置了若干快捷键，详见操作文档</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">more 要查看的文件</span><br><span class="line"></span><br><span class="line">常用快捷键：</span><br><span class="line">一行一行的看就按 Enter 键</span><br><span class="line">一页一页的看就按 空格 键</span><br><span class="line">Ctrl+B 回到上一页</span><br><span class="line">Ctrl+F 下一页</span><br><span class="line">q 立即离开more，不再显示文本内容</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">:f 输出文件名和当前行的行号</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>less 命令</strong></p>
<p>less 命令用来&#x3D;&#x3D;分屏查看文件内容&#x3D;&#x3D;，它的功能与 more 命令类似，但是<strong>更强大</strong>，支持各种显示终端</p>
<p>less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是<strong>根据显示需要加载内容</strong>，&#x3D;&#x3D;对于显示大型文件具有较高的效率&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">less 要查看的文件</span><br><span class="line"></span><br><span class="line">常用快捷键</span><br><span class="line">空格键    向下翻一页</span><br><span class="line">pagedown  向下翻一页</span><br><span class="line">pageup    向上翻一页</span><br><span class="line">/字符串   向下搜索字符串，n：向下查找 N：向上查找</span><br><span class="line">?字符串   向上搜索字符串，n：向上查找 N：向下查找</span><br><span class="line">q  离开less这个程序</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&gt; 命令</code>和<code>&gt;&gt; 命令</code></p>
<p><code>&gt; 命令</code> <strong>输出重定向</strong> : 会将原来的文件的内容覆盖</p>
<p><code>&gt;&gt; 命令</code> <strong>追加</strong>： 不会覆盖原来文件的内容，而是追加到文件的尾部</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt;文件   将ls -l 显示的内容写入文件 a.txt 中（覆盖写）如果该文件不存在，就创建该文件</span><br><span class="line">ls -al &gt;&gt;文件 将ls -al 显示的内容追加到文件 a.txt 的末尾</span><br><span class="line">cat 文件 1 &gt; 文件 2   将文件1的内容覆盖到文件2</span><br><span class="line">echo &quot;str&quot;&gt;&gt;文件  将字符串内容追加到文件中</span><br><span class="line">echo &quot;str&quot;&gt;文件   将字符串的内容覆盖到文件中，原来的内容全都没了</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>echo 命令</strong>，输出内容到控制台</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br><span class="line">例1  使用 echo 指令输出环境变量,输出当前的环境路径 ==&gt; echo $PATH</span><br><span class="line">例2  使用 echo 指令输出&quot;hello world&quot; ==&gt; echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>head 命令</strong>，用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head 文件 </span><br><span class="line">head -n 5 文件    查看文件头 5 行内容，5 可以是任意行数</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tail 命令</strong>，用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail 文件</span><br><span class="line">tail -n 5 文件    查看文件后 5 行内容，5 可以是任意行数</span><br><span class="line">tail -f 文件    实时追踪该文档的所有更新，实际开发工作中会经常使用，Ctrl+C退出追踪</span><br><span class="line">如果你是用的vim修改，因为vim实际上是删除本文件，生成了新的同名文件，所以无法进行监控</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ln 命令</strong>，给原文件创建一个链接  </p>
<p>软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径</p>
<p>硬连接指通过索引节点来进行链接</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/songgj/p/9115954.html"> 关于硬连接和软连接的详细介绍 </a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ln [参数] [原文件或目录] [目标文件或目录]  </span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖。</span><br><span class="line">-s 软链接(符号链接)。</span><br><span class="line">-d 允许超级用户制作目录的硬链接。</span><br><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line"></span><br><span class="line">在默认不带参数情况下，ln命令创建的是硬链接</span><br><span class="line"></span><br><span class="line">例： ln -s /root linkToRoot   在当前目录下创建一个软链接，链接指向root目录</span><br><span class="line">当 cd linkToRoot 时，就会跳转到root目录，但是用pwd查看路径时，还是会显示原来目录的linkToRoot的路径</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>history 命令</strong>，查看已经执行过历史命令,也可以执行历史指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history [数字]</span><br><span class="line">不加数字则显示所有的历史命令</span><br><span class="line">加数字则显示最近使用的n条命令</span><br><span class="line">!10  执行历史编号为10的命令</span><br><span class="line">history -c 清除历史记录</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-4、时间日期类指令"><a href="#7-4、时间日期类指令" class="headerlink" title="7.4、时间日期类指令"></a>7.4、时间日期类指令</h2><ol>
<li><p><strong>cal 命令</strong>，显示当前日历信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal [选项]</span><br><span class="line">不加选项，显示本月日历</span><br><span class="line">cal 2020  显示2020年一整年的日历</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>date 命令</strong>，显示当前日期 &#x2F; 设置当前日期</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">date 显示当前时间</span><br><span class="line">date +%Y   显示当前年份</span><br><span class="line">date +%m   显示当前月份</span><br><span class="line">date +%d   显示当前是哪一天</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot;   显示年月日时分秒</span><br><span class="line"></span><br><span class="line">date -s 字符串时间  设置系统当前时间</span><br><span class="line">例：date -s &quot;2020-11-11 11:11:11&quot;</span><br><span class="line">设置回原来的时间</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-5、搜索查找类指令"><a href="#7-5、搜索查找类指令" class="headerlink" title="7.5、搜索查找类指令"></a>7.5、搜索查找类指令</h2><ol>
<li><p><strong>find 命令</strong>，将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br><span class="line">-name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件  例：find /home -name hello.txt </span><br><span class="line">-user&lt;用户名&gt;  查找属于指定用户名所有文件  例： find /root -user root</span><br><span class="line">-size&lt;文件大小&gt;  按照指定的文件大小查找文件 [+n大于 -n小于 n等于]  例：find /root -size +20M</span><br><span class="line">使用文件名查找时可以使用通配符，例：find /home -name *.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>locate 命令</strong>，快速定位文件路径</p>
<p>locate 指令利用&#x3D;&#x3D;事先建立的系统中所有文件名称及路径的 locate 数据库&#x3D;&#x3D;实现快速定位给定的文件</p>
<p>Locate 指令无需遍历整个文件系统，查询速度较快</p>
<p>为了保证查询结果的准确度，管理员<strong>必须定期更新</strong> locate 时刻</p>
<p>由于 locate 指令基于数据库进行查询，所以&#x3D;&#x3D;第一次运行前，必须使用 updatedb 指令创建 locate 数据库&#x3D;&#x3D;。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate 搜索文件</span><br><span class="line">例：locate hello.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>grep 指令和 管道符号 |</strong></p>
<p>grep 过滤查找 ， 管道符<code>|</code>，表示<strong>将前一个命令的处理结果输出传递给后面的命令处理</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 查找内容 源文件</span><br><span class="line">-n 显示匹配行及行号</span><br><span class="line">-i 忽略字母大小写</span><br><span class="line"></span><br><span class="line">例：cat hello.txt | grep -n yes  在 hello.txt 文件中，查找 &quot;yes&quot; 所在行，并且显示行号</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-6、压缩和解压缩类指令"><a href="#7-6、压缩和解压缩类指令" class="headerlink" title="7.6、压缩和解压缩类指令"></a>7.6、压缩和解压缩类指令</h2><ol>
<li><p><strong>gzip &#x2F; gunzip 指令</strong></p>
<p>gzip 用于&#x3D;&#x3D;压缩文件&#x3D;&#x3D;， gunzip 用于&#x3D;&#x3D;解压缩&#x3D;&#x3D;</p>
<p>压缩完成后，原来的文件就没了，取而代之的是对应的压缩文件，不会保留原来的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件        压缩文件，只能将文件压缩为 *.gz 文件</span><br><span class="line">gunzip 文件.gz   解压缩文件命令</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>zip &#x2F; unzip 指令</strong></p>
<p>zip 用于&#x3D;&#x3D;压缩文件&#x3D;&#x3D;， unzip 用于&#x3D;&#x3D;解压缩&#x3D;&#x3D;，这个在项目打包发布中很有用的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] XXX.zip 将要压缩的内容    压缩文件和目录的命令</span><br><span class="line">unzip [选项] XXX.zip         解压缩文件</span><br><span class="line">zip ==&gt;  -r：递归压缩，即压缩目录</span><br><span class="line">unzip ==&gt;  -d&lt;目录&gt; ：指定解压后文件的存放目录</span><br><span class="line">例： zip -r home.zip /home/   ==&gt;   将 /home 下的 所有文件进行压缩成 home.zip</span><br><span class="line">例： unzip -d /home/ home.zip   ==&gt;   将 mypackge.zip 解压到 /home 目录下</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tar 指令</strong>，打包指令</p>
<p>最后打包后的文件是<code>.tar.gz</code>的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 打包的内容     打包目录，压缩后的文件格式.tar.gz</span><br><span class="line">-c 产生 .tar 打包文件</span><br><span class="line">-v 显示详细信息</span><br><span class="line">-f 指定压缩后的文件名</span><br><span class="line">-z 打包同时压缩</span><br><span class="line">-x 解包 .tar 文件</span><br><span class="line"></span><br><span class="line">-c create -t list -x extract -z gzip -j bzip2 -J xz -f filename</span><br><span class="line"></span><br><span class="line">例1 -&gt; tar -zcvf a.tar.gz a1.txt a2.txt   ==&gt;  将 a1.txt 和 a2.txt 压缩成 a.tar.gz</span><br><span class="line">例2 -&gt; tar -zcvf myhome.tar.gz /home/   ==&gt;  将 /home/ 目录下所有文件打包压缩成 myhome.tar.gz</span><br><span class="line">例3 -&gt; tar -zxvf a.tar.gz   ==&gt;  将 a.tar.gz 解压到当前目录</span><br><span class="line">例4 -&gt; tar -zxvf myhome.tar.gz -C /home/   ==&gt;  将 myhome.tar.gz 解压到 /home/ 目录下</span><br><span class="line"></span><br><span class="line">-C 应该是change，改变目录</span><br></pre></td></tr></table></figure>

<ul>
<li>指定解压缩的目标目录一定要事先存在</li>
</ul>
</li>
</ol>
<h1 id="8、组管理"><a href="#8、组管理" class="headerlink" title="8、组管理"></a>8、组管理</h1><h2 id="8-1、基本介绍"><a href="#8-1、基本介绍" class="headerlink" title="8.1、基本介绍"></a>8.1、基本介绍</h2><ul>
<li>在 linux 中的每个用户必须属于一个组，不能独立于组外</li>
<li>在 linux 中每个文件有所有者、所在组、其它组的概念<ol>
<li>所有者：一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者</li>
<li>所在组：文件也会归属于一个组，一般默认是所有者所在的组</li>
<li>其他组：除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组.</li>
</ol>
</li>
</ul>
<h2 id="8-2、文件-x2F-目录-所有者"><a href="#8-2、文件-x2F-目录-所有者" class="headerlink" title="8.2、文件 &#x2F; 目录 所有者"></a>8.2、文件 &#x2F; 目录 所有者</h2><p><strong>一般为文件的创建者</strong>，谁创建了该文件，就自然的成为该文件的所有者</p>
<ol>
<li><p>查看文件所有者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl 即可查看文件的所有者和所在组</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件所有者 &#x3D;&#x3D;&gt; change owner</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown [参数] 用户名 文件名</span><br><span class="line">chown newowner:newgroup file 改变用户的所有者和所有组</span><br><span class="line">-R 如果是目录 则使其下所有子文件或目录递归生效 递归的修改文件、目录的所有者</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="8-3、文件-x2F-目录-所在组"><a href="#8-3、文件-x2F-目录-所在组" class="headerlink" title="8.3、文件 &#x2F; 目录 所在组"></a>8.3、文件 &#x2F; 目录 所在组</h2><p>当某个用户创建了一个文件后，<strong>默认这个文件的所在组就是该用户所在的组</strong></p>
<ol>
<li><p>查看文件所在组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件所在组  &#x3D;&#x3D;&gt; change group</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [参数] 组名 文件名</span><br><span class="line">-R 如果是目录 则使其下所有子文件或目录递归生效 递归的修改文件、目录的所在组</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="9、权限管理"><a href="#9、权限管理" class="headerlink" title="9、权限管理"></a>9、权限管理</h1><h2 id="9-1、基本介绍"><a href="#9-1、基本介绍" class="headerlink" title="9.1、基本介绍"></a>9.1、基本介绍</h2><ul>
<li><p>ls -l 中显示的内容如下：</p>
<p>​	<code>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</code></p>
</li>
<li><p>0-9 位说明</p>
<ol>
<li>第 0 位确定文件类型(d 目录，- 普通文件， l 连接，c 字符设备，b 块文件例如硬盘)</li>
<li>第 1-3 位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限。—User</li>
<li>第 4-6 位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限，—Group</li>
<li>第 7-9 位确定<strong>其他组的用户</strong>拥有该文件的权限 —Other</li>
<li>这里的权限也<strong>可用数字</strong>表示为: r&#x3D;4，w&#x3D;2，x&#x3D;1 因此 rwx&#x3D;4+2+1&#x3D;7</li>
</ol>
</li>
<li><p><code>1</code> 的意思是：如果是文件，表示<strong>硬连接的数</strong>；如果是目录，则表示<strong>该目录下有多少个子目录</strong></p>
</li>
<li><p>所有者名称</p>
</li>
<li><p>所在组名称</p>
</li>
<li><p>文件大小，1213个字节，如果是目录会统一显示4096</p>
</li>
<li><p>文件最后的修改时间</p>
</li>
<li><p>文件名</p>
</li>
</ul>
<h2 id="9-2、rwx-权限详解"><a href="#9-2、rwx-权限详解" class="headerlink" title="9.2、rwx 权限详解"></a>9.2、rwx 权限详解</h2><ol>
<li><strong>rwx 作用到文件</strong><ol>
<li>[ r ]代表可读(read)：可以读取，查看</li>
<li>[ w ]代表可写(write)：可以修改，&#x3D;&#x3D;但是不代表可以删除该文件&#x3D;&#x3D;，删除一个文件的前提条件是&#x3D;&#x3D;对该文件所在的目录有写权限，才能删除该文件&#x3D;&#x3D;</li>
<li>[ x ]代表可执行(execute)：可以被执行</li>
</ol>
</li>
<li><strong>rwx 作用到目录</strong><ol>
<li>[ r ] 代表可读(read)：可以读取，ls 查看目录内容</li>
<li>[ w ] 代表可写(write)：可以修改，目录内创建+删除+重命名目录</li>
<li>[ x ] 代表可执行(execute)：可以进入该目录</li>
</ol>
</li>
</ol>
<h2 id="9-3、修改权限-–-chmod"><a href="#9-3、修改权限-–-chmod" class="headerlink" title="9.3、修改权限 – chmod"></a>9.3、修改权限 – chmod</h2><ul>
<li>通过 chmod 指令，可以修改文件或者目录的权限</li>
</ul>
<p><strong>第一种方式：通过+ 、-、&#x3D; 变更权限</strong></p>
<ul>
<li>u：所有者 g：所在组 o：其他人 a：所有人(u、g、o 的总和)</li>
<li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名   &#x3D;&#x3D;&gt;   给所有者读写操作的权限，给所在组读写权限，给其他人执行的权限</li>
<li>chmod o+w 文件目录名   &#x3D;&#x3D;&gt;   给其他人增加写权限</li>
<li>chmod a-x 文件目录名   &#x3D;&#x3D;&gt;   给所有人减少写权限</li>
</ul>
<p><strong>第二种方式：通过数字变更权限，其实就是二进制来表示，三个位分别用0和1表示权限的无和有</strong></p>
<ul>
<li>规则：r&#x3D;4 w&#x3D;2 x&#x3D;1 ，rwx&#x3D;4+2+1&#x3D;7 ，rx&#x3D;4+1&#x3D;5</li>
<li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名         相当于      chmod 751 文件目录名</li>
</ul>
<p>注意：对于目录，要拥有执行的权限才能进入目录</p>
<h1 id="10、定时任务调度"><a href="#10、定时任务调度" class="headerlink" title="10、定时任务调度"></a>10、定时任务调度</h1><h2 id="10-1、基本介绍"><a href="#10-1、基本介绍" class="headerlink" title="10.1、基本介绍"></a>10.1、基本介绍</h2><ul>
<li>crond 定时任务调度</li>
<li>在我们写了一个脚本或代码，能够完成某个任务，但是需要定时完成，就能够使用一种机制，去定时的调度我们写好的脚本或代码</li>
<li>可以通过crontab进行定时任务设置</li>
</ul>
<h2 id="10-2、基本语法"><a href="#10-2、基本语法" class="headerlink" title="10.2、基本语法"></a>10.2、基本语法</h2><ul>
<li><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p>
</li>
<li><p>任务调度分类：</p>
<ol>
<li>系统工作：有些重要的工作必须周而复始地执行，如病毒扫描等</li>
<li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab [选项]</span><br><span class="line">-e 编辑crontab定时任务</span><br><span class="line">-l 查询crontab任务</span><br><span class="line">-r 删除当前用户所有的crontab任务</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于一些简单的任务，可以不用写脚本，直接在crontab中加入任务即可</p>
</li>
<li><p>对于复杂的任务，就需要写脚本来完成（shell脚本）</p>
</li>
</ul>
<h2 id="10-3、快速入门"><a href="#10-3、快速入门" class="headerlink" title="10.3、快速入门"></a>10.3、快速入门</h2><p>任务要求：</p>
<ul>
<li>设置任务调度文件：&#x2F;etc&#x2F;crontab</li>
<li>设置个人任务调度</li>
<li>执行 crontab –e 命令</li>
<li>接着输入任务到调度文件   如：<code>*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt </code>  </li>
<li>语句的意思说每小时的每分钟执行<code>ls –l /etc/ &gt; /tmp/to.txt</code>命令</li>
</ul>
<p>具体步骤：</p>
<ul>
<li>crontab -e 进入编辑模式</li>
<li>输入代码：<code>*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt</code></li>
<li>按esc，再按i&#x2F;a&#x2F;o，就进入输入模式。按esc再按：进入末行，按esc，按R进入替换模式</li>
<li>当保存退出后就程序</li>
<li>在每一分钟都会自动的调用 ls -l &#x2F;etc &gt;&gt; &#x2F;tmp&#x2F;to.txt</li>
</ul>
<p>参数说明：</p>
<ol>
<li>五个占位符<ol>
<li>第一个 <code>*</code>  &#x3D;&gt; 一小时的第几分钟  0-59</li>
<li>第二个 <code>*</code>  &#x3D;&gt; 一天的第几小时 0-23</li>
<li>第三个<code>*</code>  &#x3D;&gt; 一个月当中的第几天 1-31</li>
<li>第四个 <code>*</code>  &#x3D;&gt; 一年当中的第几月  1-12</li>
<li>第五个 <code>*</code>  &#x3D;&gt; 一周当中的星期几  0-7（0和7都代表星期日）</li>
</ol>
</li>
<li>特殊符号的说明<ol>
<li><code>*</code> 号代表任何时间</li>
<li><code>,</code> 号代表不连续的时间</li>
<li><code>-</code>号代表连续的时间范围</li>
<li><code>*/n</code>号代表没隔多久就执行一次</li>
</ol>
</li>
<li>表达式例子：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">45 22 * * * 命令   ==&gt;  在22点45分执行命令</span><br><span class="line">0 17 * * 1 命令   ==&gt;  在每周一的17点0分执行命令</span><br><span class="line">0 5 1,15 * * 命令   ==&gt;  在每月的1号和15号的凌晨5点0分执行命令</span><br><span class="line">40 4 * * 1-5 命令   ==&gt;  每周一到周五的凌晨4点40分执行命令</span><br><span class="line">*/10 4 * * * 命令   ==&gt;  每天的凌晨4点，每个10分钟执行一次命令</span><br><span class="line">0 0 1,15 * 1 命令   ==&gt;  每月的1号和15号，每周一的0点0分都会执行命令</span><br><span class="line">注意:星期几和几号最好不要同时出现，因为他们定义的都是天，很容易产生混乱</span><br></pre></td></tr></table></figure>

<h2 id="10-4、任务调度的几个应用实例"><a href="#10-4、任务调度的几个应用实例" class="headerlink" title="10.4、任务调度的几个应用实例"></a>10.4、任务调度的几个应用实例</h2><h3 id="10-4-1、第一个案例：每隔1-分钟，就将当前的日期信息，追加到-x2F-tmp-x2F-mydate-文件"><a href="#10-4-1、第一个案例：每隔1-分钟，就将当前的日期信息，追加到-x2F-tmp-x2F-mydate-文件" class="headerlink" title="10.4.1、第一个案例：每隔1 分钟，就将当前的日期信息，追加到 &#x2F;tmp&#x2F;mydate 文件"></a>10.4.1、第一个案例：每隔1 分钟，就将当前的日期信息，追加到 &#x2F;tmp&#x2F;mydate 文件</h3><ol>
<li><p>先编写一个文件 mytask1.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &gt;&gt; /tmp/mydate</span><br></pre></td></tr></table></figure>
</li>
<li><p>给 mytask1.sh 一个可以执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 744 mytask1.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令 <code>crontab -e</code></p>
</li>
<li><p>执行 <code>*/1 * * * * mytask1.sh</code> 代码</p>
</li>
</ol>
<h3 id="10-4-2、第二个案例：每隔1-分钟，-将当前日期和日历都追加到-x2F-home-x2F-mycal-文件中"><a href="#10-4-2、第二个案例：每隔1-分钟，-将当前日期和日历都追加到-x2F-home-x2F-mycal-文件中" class="headerlink" title="10.4.2、第二个案例：每隔1 分钟， 将当前日期和日历都追加到 &#x2F;home&#x2F;mycal 文件中"></a>10.4.2、第二个案例：每隔1 分钟， 将当前日期和日历都追加到 &#x2F;home&#x2F;mycal 文件中</h3><ol>
<li><p>先编写一个文件 &#x2F;home&#x2F;mytask2.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> &gt;&gt; /tmp/mycal </span><br><span class="line">cal &gt;&gt; /tmp/mycal</span><br></pre></td></tr></table></figure>
</li>
<li><p>给 mytask1.sh 一个可以执行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 744 /home/mytask2.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>crontab -e</code> 进入定时任务调度</p>
</li>
<li><p><code>*/1 * * * * /home/mytask2.sh</code></p>
</li>
</ol>
<h3 id="10-4-3、第三个案例：每天凌晨2-00-将mysql-数据库-testdb-，备份到文件中"><a href="#10-4-3、第三个案例：每天凌晨2-00-将mysql-数据库-testdb-，备份到文件中" class="headerlink" title="10.4.3、第三个案例：每天凌晨2:00 将mysql 数据库 testdb ，备份到文件中"></a>10.4.3、第三个案例：每天凌晨2:00 将mysql 数据库 testdb ，备份到文件中</h3><ol>
<li><p>先编写一个文件 &#x2F;home&#x2F;mytask3.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/bin/mysqldump -u root -proot testdb &gt; /tmp/mydb.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>给 mytask3.sh 一个可以执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 /home/mytask3.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>crontab -e</code></p>
</li>
<li><p><code>0 2 * * * /home/mytask3.sh</code></p>
</li>
</ol>
<h2 id="10-5、crond相关指令"><a href="#10-5、crond相关指令" class="headerlink" title="10.5、crond相关指令"></a>10.5、crond相关指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conrtab –r  ==&gt;  终止任务调度</span><br><span class="line">crontab –l  ==&gt;  列出当前有那些任务调度</span><br><span class="line">service crond restart [重启任务调度]</span><br></pre></td></tr></table></figure>



<h1 id="11、Linux磁盘分区和挂载"><a href="#11、Linux磁盘分区和挂载" class="headerlink" title="11、Linux磁盘分区和挂载"></a>11、Linux磁盘分区和挂载</h1><h2 id="11-1、分区基础知识"><a href="#11-1、分区基础知识" class="headerlink" title="11.1、分区基础知识"></a>11.1、分区基础知识</h2><p><strong>分区的两种方式：</strong></p>
<ol>
<li>MBR分区（主引导记录）<ol>
<li>最多支持四个主分区</li>
<li>系统只能安装在主分区</li>
<li>扩展分区要占一个主分区</li>
<li>MBR 最大只支持 2TB，但拥有最好的兼容性</li>
</ol>
</li>
<li>GPT 分区（GUID Partition Table 全局唯一标识磁盘分区表）<ol>
<li>支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）</li>
<li>最大支持 18EB 的大容量（1EB&#x3D;1024 PB，1PB&#x3D;1024 TB ）</li>
<li>windows7 64 位以后支持 gpt</li>
</ol>
</li>
</ol>
<p><strong>Windows下的分区</strong></p>
<ul>
<li>分为主分区和扩展分区（扩展分区下面可再分逻辑分区）</li>
</ul>
<h2 id="11-2、Linux分区"><a href="#11-2、Linux分区" class="headerlink" title="11.2、Linux分区"></a>11.2、Linux分区</h2><ul>
<li><strong>原理介绍：</strong><ul>
<li>Linux 来说无论有几个分区，分给哪一目录使用，它<strong>归根结底就只有一个根目录</strong>，<strong>一个独立且唯一的文件结构</strong> , Linux 中每个分区都是用来组成整个文件系统的一部分。</li>
<li>Linux 采用了一种叫&#x3D;&#x3D;“载入”&#x3D;&#x3D;的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</li>
<li>通俗来说，就是硬盘下的分区会映射成根目录下的某个目录</li>
</ul>
</li>
<li>硬盘说明<ul>
<li>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</li>
<li>对于 IDE 硬盘，驱动器标识符为<code>hdx~</code>,其中<code>hd</code>表明分区所在设备的类型，这里是指 IDE 硬盘了。<code>x</code>为盘号（<strong>a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘</strong>）,<code>~</code>代表分区，<strong>前四个分区用数字 1 到 4 表示</strong>，它们是主分区或扩展分区，<strong>从 5 开始就是逻辑分区</strong>。例如：hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区</li>
<li>对于 SCSI 硬盘则标识为<code>sdx~</code>，SCSI 硬盘是用<code>sd</code>来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样。</li>
</ul>
</li>
<li>使用<code>lsblk 命令</code>查看当前系统的分区和挂载情况<ul>
<li>List block 显示分区</li>
<li>输入<code>lsblk -f</code> 即可查看到当前系统的分区情况和相对应的挂载目录</li>
<li>显示的内容为：<ul>
<li>分区情况、分区类型、UUID（universal unique id）唯一标识分区的40位不重复的字符串、挂载点</li>
</ul>
</li>
<li>如果想看大小，可以直接输入<code>lsblk</code>查看</li>
</ul>
</li>
</ul>
<h2 id="11-3、新增硬盘并挂载的详细步骤"><a href="#11-3、新增硬盘并挂载的详细步骤" class="headerlink" title="11.3、新增硬盘并挂载的详细步骤"></a>11.3、新增硬盘并挂载的详细步骤</h2><p>案例：给 Linux 系统增加一个新的硬盘，并且挂载到 <code>/home/newdisk</code></p>
<ol>
<li><p><strong>虚拟机添加硬盘</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟机  -&gt;  设置  -&gt;  硬件  -&gt;  添加  -&gt;  选择硬盘，下一步  -&gt;  SCSI虚拟磁盘类型  -&gt;  分配空间  -&gt; 完成</span><br><span class="line">系统重启，再使用 lsblk -f 查看硬盘分区情况，可以查看到一个没有分区的硬盘sdb</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分区</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb  进入分区引导</span><br><span class="line">m  寻求帮助</span><br><span class="line">n  添加一个新的分区</span><br><span class="line">p  设置为主分区  e是扩展分区</span><br><span class="line">选择主分区编号</span><br><span class="line">回车 + 回车，两次回车默认剩余全部空间</span><br><span class="line">w 分区信息写入硬盘并退出</span><br><span class="line">再使用 lsblk -f 查看分区情况可以发现只有分区sdb1但是没有对应的信息，这就是因为还没有格式化</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>格式化</strong>（MakeFileSystem）– 创建文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfs -t ext4 /dev/sdb1   </span><br><span class="line">意思就是：把 sdb1 格式化成 ext4 这种分区类型</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>挂载</strong>，将一个分区和一个目录联系起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先创建一个目录 /home/newdisk</span><br><span class="line">mount /dev/sdb1 /home/newdisk   -&gt;     挂载</span><br><span class="line">但是这样的设置挂载，当你重启机器的时候，硬盘和目录的挂载关系就会没有了，这个只是临时挂载</span><br><span class="line"></span><br><span class="line">如果想不挂载了，就使用umount 设备名称 或者 挂载目录</span><br><span class="line">例如： umount /dev/sdb1 或 者 umount /newdisk</span><br><span class="line">要想设置永久，就需要设置一个文件</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置可以自动挂载</strong>（永久挂载），当你重启系统，仍然可以挂载到 &#x2F;home&#x2F;newdisk</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编辑一个文件 vim /etc/fstab  这个文件就记录着分区和挂载点的情况</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">编辑其中的内容</span><br><span class="line">添加一行映射关系代码</span><br><span class="line">/dev/sdb1                      /home/newdisk ext4 default 0 0</span><br><span class="line">保存退出</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">编辑完成后</span><br><span class="line">mount -a </span><br><span class="line">-a 就是自动挂载</span><br><span class="line">重启过后就能发现是永久挂载了</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-4、查看磁盘情况"><a href="#11-4、查看磁盘情况" class="headerlink" title="11.4、查看磁盘情况"></a>11.4、查看磁盘情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [选项]   -&gt;  查询系统整体磁盘使用情况</span><br><span class="line">-l   列表显示</span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> [选项] [目录]  -&gt;  查询指定目录的磁盘占用情况，默认为当前目录</span><br><span class="line">-s   指定目录占用大小汇总</span><br><span class="line">-h   带计量单位</span><br><span class="line">-a   含文件</span><br><span class="line">--max-depth=1   子目录深度</span><br><span class="line">-c   列出明细的同时，增加汇总值</span><br><span class="line"></span><br><span class="line">例1 -&gt; 查询 /opt 目录的磁盘占用情况，深度为 1  -&gt;  <span class="built_in">du</span> -ach --max-depth=1 /opt</span><br><span class="line">例2 -&gt; 统计/home 文件夹下文件的个数  -&gt;  <span class="built_in">ls</span> -l /home | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">例3 -&gt; 统计/home 文件夹下目录的个数  -&gt;  <span class="built_in">ls</span> -l /home | grep <span class="string">&quot;^d&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">例4 -&gt; 统计/home 文件夹下文件的个数，包括子文件夹里的  -&gt;  <span class="built_in">ls</span> -lR /home | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">例5 -&gt; 统计文件夹下目录的个数，包括子文件夹里的  -&gt;  <span class="built_in">ls</span> -lR /home | grep <span class="string">&quot;^d&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line">例6 -&gt; 以树状显示目录结构  -&gt;  先yum install tree，再tree</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">用了管道符分隔，先列出来，再过滤，再统计</span><br><span class="line"><span class="string">&quot;^-&quot;</span>中 ^ 是定位符，表示开头   -表示以-开头的</span><br><span class="line"><span class="built_in">ls</span>参数是区分大小写的  -&gt; 大写的R代表递归，小写的r（reverse）代表逆序</span><br></pre></td></tr></table></figure>

<h1 id="12、网络配置"><a href="#12、网络配置" class="headerlink" title="12、网络配置"></a>12、网络配置</h1><h2 id="12-1、常用指令"><a href="#12-1、常用指令" class="headerlink" title="12.1、常用指令"></a>12.1、常用指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows下查看ip地址  -&gt;  ipconfig</span><br><span class="line">Linux下查看ip地址  -&gt;  ifconfig</span><br><span class="line"></span><br><span class="line">测试两个主机之间网路是否联通  -&gt;  ping ip地址</span><br></pre></td></tr></table></figure>

<h2 id="12-2、Linux网络环境配置"><a href="#12-2、Linux网络环境配置" class="headerlink" title="12.2、Linux网络环境配置"></a>12.2、Linux网络环境配置</h2><ol>
<li><p>可以通过<strong>图形化界面</strong>进行设置，设置<strong>自动连接</strong></p>
<ul>
<li>linux 启动后会自动获取 IP，<strong>缺点是每次自动获取的 ip 地址可能不一样</strong></li>
<li>这个不适用于做服务器，因为我们的服务器的 ip 需要是固定的</li>
</ul>
</li>
<li><p>通过<strong>修改配置文件指定固定ip</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">直接修改配置文件来指定IP，并可以连接到外网   -&gt;   /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">第一个显卡就是eth0，第二个就是eth1</span><br><span class="line"></span><br><span class="line">例：要将 ip 地址配置成静态的，ip 地址为 192.168.184.130</span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0    -&gt;  打开配置文件</span><br><span class="line">Linux会显示文件内容，其中要修改的内容如下 ↓↓↓↓</span><br><span class="line">DEVICE=eth0   -&gt;接口名（设备，网卡）</span><br><span class="line">HWADDR=00:0c:2x:6x:0x:xx   -&gt;  MAC地址</span><br><span class="line">TYPE=Ethernet   -&gt;  网络类型</span><br><span class="line">UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44   -&gt;  随机ID</span><br><span class="line">ONBOOT=<span class="built_in">yes</span>    -&gt;   系统启动的时候网络接口是否有效  静态，ONBOOT为<span class="built_in">yes</span>；自动，ONBOOT为no</span><br><span class="line">BOOTPROTO=static   -&gt; 以静态方式获得ip，还有bootp采用BOOTP协议 dhcp采用DHCP协议 none不使用协议</span><br><span class="line">IPADDR=192.168.184.130   -&gt;  指定ip</span><br><span class="line">GATEWAY=192.168.184.2   -&gt;  网关</span><br><span class="line">DNS1=192.168.184.2   -&gt;  dns和网关保持一致即可</span><br><span class="line"></span><br><span class="line">修改后，一定要 重启服务</span><br><span class="line">service network restart</span><br><span class="line">或者直接  reboot 重启系统</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="13、进程管理"><a href="#13、进程管理" class="headerlink" title="13、进程管理"></a>13、进程管理</h1><h2 id="13-1、进程的基本介绍"><a href="#13-1、进程的基本介绍" class="headerlink" title="13.1、进程的基本介绍"></a>13.1、进程的基本介绍</h2><ul>
<li>在 LINUX 中，<strong>每个执行的程序（代码）都称为一个进程</strong>。每一个进程都<strong>分配一个 ID 号</strong></li>
<li><strong>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程</strong>。例如 www 服务器</li>
<li><strong>每个进程都可能以两种方式存在的，前台与后台</strong>。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作（也称为守护进程），但由于屏幕上无法看到的进程，通常使用后台方式执行</li>
<li><strong>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中</strong>。直到关机才才结束</li>
</ul>
<h2 id="13-2、显示系统执行的进程"><a href="#13-2、显示系统执行的进程" class="headerlink" title="13.2、显示系统执行的进程"></a>13.2、显示系统执行的进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">查看进行使用的指令是 ps ,一般来说使用的参数是 ps -aux</span><br><span class="line">-a  显示当前终端所有的进程信息</span><br><span class="line">-u  以用户的格式显示进程信息</span><br><span class="line">-x  显示后台进程运行的参数</span><br><span class="line">-e  显示所有进程</span><br><span class="line">-f  全格式</span><br><span class="line"></span><br><span class="line">PID   进程识别号</span><br><span class="line">TTY   终端机号</span><br><span class="line">TIME  此进程所消CPU时间</span><br><span class="line">CMD   正在执行的命令或进程名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例1：输入指令 ps -aux | more</span><br><span class="line">USER   PID   %CPU  %MEM   VSZ   RSS   TTY   STAT    START    TIME     COMMAND</span><br><span class="line"></span><br><span class="line">详解</span><br><span class="line">System V 展示风格</span><br><span class="line">USER：用户名称</span><br><span class="line">PID：进程号</span><br><span class="line">%CPU：进程占用 CPU 的百分比</span><br><span class="line">%MEM：进程占用物理内存的百分比</span><br><span class="line">VSZ：进程占用的虚拟内存大小（单位：KB）</span><br><span class="line">RSS：进程占用的物理内存大小（单位：KB）</span><br><span class="line">TTY：终端名称</span><br><span class="line">STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</span><br><span class="line">STARTED：进程的启动时间</span><br><span class="line">TIME：CPU 时间，即进程使用 CPU 的总时间</span><br><span class="line">COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例2：输入指令 ps -ef | more</span><br><span class="line">UID  PID  PPID   C  STIME  TTY   TIME   CMD</span><br><span class="line"></span><br><span class="line">详解：</span><br><span class="line">UID：用户 ID</span><br><span class="line">PID：进程 ID</span><br><span class="line">PPID：父进程 ID</span><br><span class="line">C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</span><br><span class="line">STIME：进程启动的时间</span><br><span class="line">TTY：完整的终端名称</span><br><span class="line">TIME：CPU 时间</span><br><span class="line">CMD：启动进程所用的命令和参数</span><br></pre></td></tr></table></figure>

<h2 id="13-3、终止进程-kill-和-killall"><a href="#13-3、终止进程-kill-和-killall" class="headerlink" title="13.3、终止进程 kill 和 killall"></a>13.3、终止进程 kill 和 killall</h2><ul>
<li>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程</li>
<li>可使用 kill 命令来完成此项任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [选项] 进程号    -&gt;   通过进程号杀死进程</span><br><span class="line">-9  表示强迫进程立即停止</span><br><span class="line"></span><br><span class="line">killall 进程名称      -&gt;   通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">踢掉某个用户  -&gt;  ps -aux | grep sshd  -&gt;  查看进程号  -&gt;  <span class="built_in">kill</span> 4010</span><br><span class="line">终止多个 gedit 编辑器  -&gt;  killall gedit</span><br><span class="line">强制杀掉一个终端  -&gt;  <span class="built_in">kill</span> -9 4090</span><br></pre></td></tr></table></figure>

<h2 id="13-4、查看进程树"><a href="#13-4、查看进程树" class="headerlink" title="13.4、查看进程树"></a>13.4、查看进程树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] </span><br><span class="line">-p :显示进程的 PID</span><br><span class="line">-u :显示进程的所属用户</span><br><span class="line"></span><br><span class="line">例子：请你树状的形式显示进程的 pid</span><br><span class="line">pstree -p</span><br></pre></td></tr></table></figure>

<h2 id="13-5、服务管理"><a href="#13-5、服务管理" class="headerlink" title="13.5、服务管理"></a>13.5、服务管理</h2><ul>
<li><strong>服务(service) 本质就是进程</strong>，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如（mysql , sshd 防火墙等），因此我们又称为<strong>守护进程</strong>，是 Linux 中非常重要的知识点。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start | stop | restart | reload | status]</span><br><span class="line">CentOS7.0 后 不再使用 service ,而是 systemctl</span><br><span class="line"></span><br><span class="line">查看服务名：</span><br><span class="line">1.使用setup-&gt;系统服务查看   CentOS7是nmtui   使用tab切换到[确定]和[取消]</span><br><span class="line">2.查看目录 <span class="built_in">ls</span> -l /etc/init.d/    CentOS7使用 systemctl list-unit-files 可以列出所有的服务</span><br></pre></td></tr></table></figure>

<h2 id="13-6、查看防火墙"><a href="#13-6、查看防火墙" class="headerlink" title="13.6、查看防火墙"></a>13.6、查看防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看当前防火墙的状况   -&gt;    service iptables status  CentOS7改为  systemctl status firewalld</span><br><span class="line">关闭防火墙    -&gt;    service iptables stop  CentOS7改为  systemctl stop firewalld</span><br><span class="line">开启防火墙    -&gt;    service iptables start  CentOS7改为  systemctl start firewalld</span><br><span class="line"></span><br><span class="line">检查Linux的某个端口是否在监听并且可以访问    -&gt;    telnet ip 端口号  例如 telnet 192.168.1.30 22</span><br><span class="line">yum list telnet*   yum install telnet-server  yum install telnet.*   按照这三条指令先安装亲测有效</span><br><span class="line"></span><br><span class="line">注意！</span><br><span class="line">1. 关闭或者启用防火墙后，立即生效</span><br><span class="line">2. 这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置</span><br><span class="line">3. 如果希望设置某个服务自启动或关闭永久生效，要使用 chkconfig 指令</span><br></pre></td></tr></table></figure>

<h2 id="13-7、chkconfig-指令"><a href="#13-7、chkconfig-指令" class="headerlink" title="13.7、chkconfig 指令"></a>13.7、<strong>chkconfig 指令</strong></h2><ul>
<li>通过<code>chkconfig</code> 命令可以<strong>给每个服务的各个运行级别设置自启动&#x2F;关闭</strong></li>
<li>但是这个指令只能在CentOS中使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list|grep xxx     -&gt;  查看服务 </span><br><span class="line">chkconfig 服务名 --list        -&gt;  查看服务 </span><br><span class="line">chkconfig --level 5 服务名 on/off   -&gt;  修改服务在某个运行级别下的自启动</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">案例 1： 请显示当前系统所有服务的各个运行级别的运行状态  -&gt;   chkconfig --list</span><br><span class="line">案例 2：请查看 sshd 服务的运行状态  -&gt;   service sshd status</span><br><span class="line">案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动，看看有什么效果？  -&gt;   chkconfig --level 5 sshd off</span><br><span class="line">案例 4： 当运行级别为 5 时，关闭防火墙  -&gt;   chkconfig --level 5 iptables off</span><br><span class="line">案例 5： 在所有运行级别下，关闭防火墙  -&gt;   chkconfig iptables off</span><br><span class="line">案例 6： 在所有运行级别下，开启防火墙  -&gt;   chkconfig iptables on3</span><br></pre></td></tr></table></figure>

<ul>
<li>chkconfig 重新设置服务后自启动或关闭，&#x3D;&#x3D;需要重启机器 reboot 才能生效&#x3D;&#x3D;</li>
</ul>
<h2 id="13-8、动态监控进程"><a href="#13-8、动态监控进程" class="headerlink" title="13.8、动态监控进程"></a>13.8、动态监控进程</h2><ul>
<li><p>top 与 ps 命令很相似，它们都用来显示正在执行的进程</p>
</li>
<li><p>Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程</p>
</li>
<li><p>有点类似于Windows下的任务管理器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br><span class="line">选项说明：</span><br><span class="line">-d 秒数  -&gt;  指定top命令每隔几秒更新，默认是3秒在top命令的交互模式当中可以执行的命令</span><br><span class="line">-i   -&gt;   使top不显示任何进闲置或僵死进程</span><br><span class="line">-p   -&gt;   通过指定监控进程ID来仅仅监控某个进程的状态</span><br><span class="line">交互操作说明</span><br><span class="line">P  -&gt;  以CPU使用率排序</span><br><span class="line">M  -&gt;  以内存使用率排序</span><br><span class="line">N  -&gt;  以PID排序</span><br><span class="line">q  -&gt;  退出top</span><br><span class="line">输入u后输入某个用户名  -&gt;  查看该用户名的服务</span><br><span class="line">输入k，回车，再输入一个进程ID号  -&gt;  终止指定的进程</span><br></pre></td></tr></table></figure>

<h2 id="13-9、查看系统网路情况-netstat"><a href="#13-9、查看系统网路情况-netstat" class="headerlink" title="13.9、查看系统网路情况 netstat"></a>13.9、查看系统网路情况 netstat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net [选项]</span><br><span class="line">-an  -&gt;  按一定顺序排列输出</span><br><span class="line">-p  -&gt;  显示哪个进程在调用</span><br><span class="line"></span><br><span class="line">案例1:查看系统所有的网络服务  -&gt;  netstat -anp | more</span><br><span class="line">案例2:查看系统某一个网络服务  -&gt;  netstat -anp | grep sshd</span><br></pre></td></tr></table></figure>



<h1 id="14、RPM"><a href="#14、RPM" class="headerlink" title="14、RPM"></a>14、RPM</h1><h2 id="14-1、基本介绍"><a href="#14-1、基本介绍" class="headerlink" title="14.1、基本介绍"></a>14.1、基本介绍</h2><p>RPM是一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中，生成具有<code>.RPM </code>扩展名的文件</p>
<p>RPM 是 <code>RedHat Package Manager</code>（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的</p>
<p>Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p>
<h2 id="14-2、查询RPM包"><a href="#14-2、查询RPM包" class="headerlink" title="14.2、查询RPM包"></a>14.2、查询RPM包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa  -&gt;  查询所安装的所有rpm 软件包</span><br><span class="line">rpm -qa | more   -&gt;  分页显示</span><br><span class="line">rpm -qa | grep X [rpm -qa | grep firefox]  -&gt;  指定查找某个软件</span><br><span class="line">rpm -qi 软件包名  -&gt;  查询软件包信息</span><br><span class="line">rpm -ql 软件包名  -&gt;   查询软件包中的文件</span><br><span class="line">rpm -qf 文件全路径名   -&gt;  查询文件所属的软件包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基本格式：</span><br><span class="line">一个 rpm 包名：firefox-45.0.1-1.el6.centos.x86_64.rpm </span><br><span class="line">名称:firefox</span><br><span class="line">版本号：45.0.1-1</span><br><span class="line">适用操作系统: el6.centos.x86_64</span><br><span class="line">表示 centos6.x 的 64 位系统</span><br><span class="line">如果是 i686、i386 表示 32 位系统，noarch 表示通用</span><br></pre></td></tr></table></figure>

<h2 id="14-3、安装RPM包"><a href="#14-3、安装RPM包" class="headerlink" title="14.3、安装RPM包"></a>14.3、安装RPM包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh RPM包的全路径名称</span><br><span class="line">i=install 安装</span><br><span class="line">v=verbose 提示</span><br><span class="line">h=<span class="built_in">hash</span>  进度条</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="14-4、卸载RPM包"><a href="#14-4、卸载RPM包" class="headerlink" title="14.4、卸载RPM包"></a>14.4、卸载RPM包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rpm -e RPM包名</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：</span><br><span class="line">$ rpm -e foo</span><br><span class="line">removing these packages would <span class="built_in">break</span> dependencies:foo is needed by bar-1.0-1</span><br><span class="line">2. 如果我们就是要删除 foo 这个 rpm 包，可以增加参数 --nodeps ，就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行</span><br><span class="line">如：$ rpm -e --nodeps foo</span><br><span class="line">带上 --nodeps 就是强制删除。</span><br></pre></td></tr></table></figure>

<h1 id="15、YUM"><a href="#15、YUM" class="headerlink" title="15、YUM"></a>15、YUM</h1><h2 id="15-1、基本介绍"><a href="#15-1、基本介绍" class="headerlink" title="15.1、基本介绍"></a>15.1、基本介绍</h2><ul>
<li>Yum 是一个 <strong>Shell 前端软件包管理器</strong></li>
<li>YUM 基于 RPM 包管理，<strong>能够从指定的服务器自动下载 RPM 包并且安装</strong>，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。<strong>使用 yum 的前提是已经联网</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本指令：</span><br><span class="line">查询 yum 服务器是否有需要安装的软件  -&gt;  yum list|grep xx 软件列表</span><br><span class="line">下载安装指定的 yum 包  -&gt;  yum install xxx </span><br></pre></td></tr></table></figure>

<h2 id="15-2、安装YUM包"><a href="#15-2、安装YUM包" class="headerlink" title="15.2、安装YUM包"></a>15.2、安装YUM包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先查询软件列表  -&gt;   yum list|grep jdk</span><br><span class="line">安装包  yum install java-1.8.0-openjdk.i686</span><br><span class="line"></span><br><span class="line">一般会默认安装最新的，你也可以指定安装某个包</span><br><span class="line">安装完成过后会删除安装包</span><br></pre></td></tr></table></figure>

<p>如果需要卸载，直接通过RPM包管理卸载即可</p>
<h1 id="16、JAVAEE环境安装"><a href="#16、JAVAEE环境安装" class="headerlink" title="16、JAVAEE环境安装"></a>16、JAVAEE环境安装</h1><h2 id="16-1、需要安装jdk"><a href="#16-1、需要安装jdk" class="headerlink" title="16.1、需要安装jdk"></a>16.1、需要安装jdk</h2><ul>
<li>这里安装 Java8 版本，而且是通过官网下载的压缩包进行解压，再配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先将软件通过 xftp5 上传到 /opt 下</span><br><span class="line">解压缩到 /opt  -&gt;   tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br><span class="line">配置环境变量的配置文件 vim /etc/profile</span><br><span class="line">	JAVA_HOME=/opt/jdk1.7.0_79    -&gt;  JavaHome</span><br><span class="line">	PATH=/opt/jdk1.7.0_79/bin:<span class="variable">$PATH</span>   -&gt;  路径</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME PATH   -&gt;   输出变量，环境变量生效</span><br><span class="line">需要注销用户，环境变量才能生效  -&gt;  运行级别3就<span class="built_in">logout</span>，运行级别5就重启</span><br><span class="line">输入 java -version  和  javac -version  查看是否配置成功</span><br></pre></td></tr></table></figure>



<h2 id="16-2、需要安装tomcat"><a href="#16-2、需要安装tomcat" class="headerlink" title="16.2、需要安装tomcat"></a>16.2、需要安装tomcat</h2><ul>
<li>一般spring boot项目会自带tomcat，就不需要安装，传统的SSM和SSH就需要tomcat服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">上传文件过后解压缩到/opt</span><br><span class="line">启 动 tomcat ./startup.sh	</span><br><span class="line">	进入bin目录  -&gt;  <span class="built_in">cd</span> apache-tomcat-7.0.70/bin/</span><br><span class="line">	<span class="built_in">ls</span> 查看目录内文件</span><br><span class="line">	执行脚本文件  -&gt;  ./startup.sh</span><br><span class="line">开放端口 8080 这样外网才能访问到 tomcat</span><br><span class="line">	vim /etc/sysconfig/iptables</span><br><span class="line">	将开放22号端口的哪一行代码复制粘贴，将22改成8080即可开放8080端口</span><br><span class="line">	Centos7 -&gt; firewall-cmd --permanent --add-port=8080/tcp  -&gt;  firewall-cmd --reload</span><br><span class="line">	centos8 -&gt; firewall-cmd --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure>

<ul>
<li>CentOS7 安装tomcat9可以查看教程 ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mmmbox/article/details/89461518">https://blog.csdn.net/mmmbox/article/details/89461518</a></li>
</ul>
<h2 id="16-3、需要安装数据库，这里安装MySQL"><a href="#16-3、需要安装数据库，这里安装MySQL" class="headerlink" title="16.3、需要安装数据库，这里安装MySQL"></a>16.3、需要安装数据库，这里安装MySQL</h2><ul>
<li>可查看教程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nicknailo/articles/8563737.html">https://www.cnblogs.com/nicknailo/articles/8563737.html</a></li>
<li>初始密码的要求参数：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/newbest/p/9753706.html">https://www.cnblogs.com/newbest/p/9753706.html</a></li>
</ul>
<h2 id="16-4、如果是图形界面，还需要安装一款ide"><a href="#16-4、如果是图形界面，还需要安装一款ide" class="headerlink" title="16.4、如果是图形界面，还需要安装一款ide"></a>16.4、如果是图形界面，还需要安装一款ide</h2><ul>
<li>这个可以直接在图形界面的软件商店中安装</li>
</ul>
<h1 id="17、Shell编程"><a href="#17、Shell编程" class="headerlink" title="17、Shell编程"></a>17、Shell编程</h1><h2 id="17-1、为什么要学Shell编程"><a href="#17-1、为什么要学Shell编程" class="headerlink" title="17.1、为什么要学Shell编程"></a>17.1、为什么要学Shell编程</h2><ol>
<li>Linux 运维工程师在进行服务器集群管理时，需要<strong>编写 Shell 程序来进行服务器管理</strong>。</li>
<li>对于 JavaEE 和 Python 程序员来说，工作的需要，你的老大会要求你编写一些<strong>Shell 脚本</strong>进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。</li>
<li>对于大数据程序员来说，需要编写 Shell 程序来<strong>管理集群</strong>。</li>
</ol>
<h2 id="17-2、Shell是什么"><a href="#17-2、Shell是什么" class="headerlink" title="17.2、Shell是什么"></a>17.2、Shell是什么</h2><ul>
<li>Shell 是一个命令行解释器，它为用户提供了一个向Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序</li>
<li>在我们使用的过程中，应用程序调用shell或者我们直接执行shell脚本，然后shell操作Linux内核，内核再驱动硬件</li>
<li><font color=red>shell主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果，通过shell解析给用户</font></li>
<li>&#x3D;&#x3D;shell是外壳程序的统称，bash 是具体的一种shell&#x3D;&#x3D;</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/190417/1-1Z41G31T3628.gif"></p>
<ul>
<li>Shell编程开发原理</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180911114843294?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTkyOTc0ODUwMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<h2 id="17-3、Shell脚本执行方式"><a href="#17-3、Shell脚本执行方式" class="headerlink" title="17.3、Shell脚本执行方式"></a>17.3、Shell脚本执行方式</h2><ol>
<li><p><strong>格式要求</strong>：</p>
<ul>
<li>脚本以<code>#!/bin/bash</code> 开头</li>
<li>脚本需要有可执行权限</li>
</ul>
</li>
<li><p><strong>快速写一个 输出 helloworld 的脚本</strong> <code>hello.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash    -&gt;  表示shell脚本用bash来解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常用执行方式</strong>：</p>
<ol>
<li><p><strong>输入脚本的绝对路径或相对路径</strong>，即可执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 744 hello.sh   -&gt;  给所有者一个执行权限</span><br><span class="line">./hello.sh   -&gt;   相对路径</span><br><span class="line">/root/shell/hello.sh   -&gt;   绝对路径</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输入指令</strong>：<code>sh 脚本路径</code>   这样可以不用赋予脚本执行权限，直接执行，但是&#x3D;&#x3D;不推荐&#x3D;&#x3D;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh ./hello.sh   -&gt;   通过相对路径</span><br><span class="line">sh /root/shell/hello/sh   -&gt;   通过绝对路径</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="17-4、Shell的变量"><a href="#17-4、Shell的变量" class="headerlink" title="17.4、Shell的变量"></a>17.4、Shell的变量</h2><h3 id="17-4-1、Shell变量的介绍"><a href="#17-4-1、Shell变量的介绍" class="headerlink" title="17.4.1、Shell变量的介绍"></a>17.4.1、Shell变量的介绍</h3><ul>
<li>Linux Shell 中的变量分为，&#x3D;&#x3D;系统变量&#x3D;&#x3D;和&#x3D;&#x3D;用户自定义变量&#x3D;&#x3D;。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统变量：$HOME、$PWD、$SHELL、$USER 等   比如： echo &quot;path=$PATH&quot;</span><br><span class="line">显示当前 shell 中所有变量：set</span><br></pre></td></tr></table></figure>

<h3 id="17-4-2、Shell变量的定义"><a href="#17-4-2、Shell变量的定义" class="headerlink" title="17.4.2、Shell变量的定义"></a>17.4.2、Shell变量的定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义变量：变量=值</span><br><span class="line">撤销变量：unset 变量</span><br><span class="line">声明静态变量：readonly 变量，  注意：不能unset!</span><br><span class="line">把变量提升为全局环境变量，可供其他 shell 程序使用   --&gt; 详情见下一节 设置环境变量</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">A=100</span><br><span class="line">readonly B=99</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">unset A</span><br></pre></td></tr></table></figure>

<h3 id="17-4-3、定义变量的规则"><a href="#17-4-3、定义变量的规则" class="headerlink" title="17.4.3、定义变量的规则"></a>17.4.3、定义变量的规则</h3><ol>
<li>变量名称可以由<strong>字母、数字和下划线</strong>组成，但是<strong>不能以数字</strong>开头。</li>
<li><strong>等号两侧不能有空格</strong></li>
<li>变量名称一般习惯为<strong>大写</strong></li>
</ol>
<h3 id="17-4-4、将命令的返回值赋给变量（重点）"><a href="#17-4-4、将命令的返回值赋给变量（重点）" class="headerlink" title="17.4.4、将命令的返回值赋给变量（重点）"></a>17.4.4、将命令的返回值赋给变量（重点）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=`ls -la`   用反引号将命令括起来 -&gt; 运行里面的命令并把结果返回给变量 A</span><br><span class="line">A=$(ls -la)  等价于反引号</span><br></pre></td></tr></table></figure>

<h2 id="17-5、设置环境变量"><a href="#17-5、设置环境变量" class="headerlink" title="17.5、设置环境变量"></a>17.5、设置环境变量</h2><h3 id="17-5-1、基本语法"><a href="#17-5-1、基本语法" class="headerlink" title="17.5.1、基本语法"></a>17.5.1、基本语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> 变量名=变量值  -&gt;  将 shell 变量输出为环境变量</span><br><span class="line"><span class="built_in">source</span> 配置文件   -&gt;  让修改后的配置信息立即生效</span><br><span class="line"><span class="built_in">echo</span> $变量名   -&gt;  查询环境变量的值</span><br></pre></td></tr></table></figure>

<ul>
<li>例如，在 &#x2F;etc&#x2F;profile 中设置一个环境变量<code>$TOMCAT_HOME</code> ，在我们自己写得shell脚本中引用，但是在配置过后，为了让 &#x2F;etc&#x2F;profile 中的环境变量生效，需要使用 <code>source /etc/profile</code> 或者重启系统&#x2F;注销用户才能生效，类似于一个全局变量</li>
</ul>
<h3 id="17-5-2、快速入门"><a href="#17-5-2、快速入门" class="headerlink" title="17.5.2、快速入门"></a>17.5.2、快速入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /etc/profile</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义一个环境变量</span> </span><br><span class="line">TOMCAT_HOME=&#x27;helloworld&#x27;</span><br><span class="line">export TOMCAT_HOME</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要使用 <span class="built_in">source</span> /etc/profile 指令重新加载，不然使用不了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim ./hello.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;$TOMCAT_HOME&quot;</span><br></pre></td></tr></table></figure>

<h2 id="17-6、位置参数变量"><a href="#17-6、位置参数变量" class="headerlink" title="17.6、位置参数变量"></a>17.6、位置参数变量</h2><h3 id="17-6-1、介绍"><a href="#17-6-1、介绍" class="headerlink" title="17.6.1、介绍"></a>17.6.1、介绍</h3><p>当我们执行一个 shell 脚本时，如果希望<strong>获取到命令行的参数信息</strong>，就可以使用到位置参数变量</p>
<p>比如 ：</p>
<p><code>./myshell.sh 100 200</code> , 这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息</p>
<h3 id="17-6-2、基本语法"><a href="#17-6-2、基本语法" class="headerlink" title="17.6.2、基本语法"></a>17.6.2、基本语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">n   -&gt; n 为数字，<span class="variable">$0</span> 代表命令本身，<span class="variable">$1</span>-<span class="variable">$9</span> 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<span class="variable">$&#123;10&#125;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">*   -&gt;   这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@   -&gt;   这个变量也代表命令行中所有的参数，不过<span class="variable">$@</span>把每个参数区分对待</span></span><br><span class="line">===&gt; 这两者的区别可以到循环语句的for循环语句存中查看区别</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment">#   -&gt;   这个变量代表命令行中所有参数的个数</span></span></span><br></pre></td></tr></table></figure>

<h3 id="17-6-3-应用实例"><a href="#17-6-3-应用实例" class="headerlink" title="17.6.3 应用实例"></a>17.6.3 应用实例</h3><ul>
<li>编写一个 shell 脚本 positionPara.sh ， 在脚本中获取到命令行的各个参数信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取各个参数</span></span><br><span class="line">echo $0 $1 $2</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br><span class="line">echo &quot;参数个数=$#&quot;</span><br><span class="line"></span><br><span class="line">输入 ./positionPara.sh 100 200 300 后的输出效果</span><br><span class="line">./positionPara.sh 100 200</span><br><span class="line">100 200 300</span><br><span class="line">100 200 300 </span><br><span class="line">参数个数=3</span><br></pre></td></tr></table></figure>

<h2 id="17-7、预定义变量"><a href="#17-7、预定义变量" class="headerlink" title="17.7、预定义变量"></a>17.7、预定义变量</h2><ol>
<li><p>基本介绍</p>
<ul>
<li>预定义变量就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用</li>
</ul>
</li>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$  -&gt;  当前进程的进程号（PID）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">!  -&gt;  后台运行的最后一个进程的进程号（PID）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">？ -&gt;  最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编写脚本 test.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前的进程号=$$&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台的方式运行 ./myshell.sh 这个脚本</span></span><br><span class="line">./myshell.sh &amp;</span><br><span class="line">echo &quot;最后的进程号=$!&quot;</span><br><span class="line">echo &quot;最后一次执行的命令的返回状态：$?&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出效果：</span><br><span class="line">当前的进程号=22083</span><br><span class="line">最后的进程号=22084</span><br><span class="line">最后一次执行的命令的返回状态：0</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-8、运算符"><a href="#17-8、运算符" class="headerlink" title="17.8、运算符"></a>17.8、运算符</h2><ol>
<li><p><strong>基本介绍</strong></p>
<ul>
<li>可以在 shell 中进行各种运算操作</li>
</ul>
</li>
<li><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;<span class="subst">$((运算式)</span>)&quot;</span>或<span class="string">&quot;$[运算式]&quot;</span>   -&gt;   推荐使用 $[运算式]</span><br><span class="line"><span class="built_in">expr</span> m + n   -&gt;  注意 <span class="built_in">expr</span> 运算符间要有空格</span><br><span class="line"><span class="built_in">expr</span> m - n</span><br><span class="line"><span class="built_in">expr</span> \*, /, %   -&gt; 乘，除，取余</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">计算（2+3）X4 的值</span><br><span class="line">    $((运算式))  -&gt;  RESULT1=$(((2+3)*4))</span><br><span class="line">    $[运算式]  -&gt;  RESULT2=$[(2+3)*4]</span><br><span class="line">    expr  -&gt;   TEMP=`expr 2 + 3`</span><br><span class="line">			  RESULT3=`expr $TEMP \* 4`</span><br><span class="line">请求出命令行的两个参数[整数]的和</span><br><span class="line">	SUM=$[$1+$2]</span><br><span class="line">	echo &quot;SUM=$SUM&quot;</span><br><span class="line">	输入指令 ./shelltest.sh 100 200 即可看到输出结果为 SUM=300</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-9、条件判断"><a href="#17-9、条件判断" class="headerlink" title="17.9、条件判断"></a>17.9、条件判断</h2><ol>
<li><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ condition ] （注意 condition 前后要有空格）#非空返回 true，可使用$?验证（0 为 true，&gt;1 为 false）</span><br><span class="line"></span><br><span class="line">一些案例：</span><br><span class="line">[ string ]   -&gt;   返回true</span><br><span class="line">[ ]   -&gt;   返回false</span><br><span class="line">[ condition ] &amp;&amp; echo OK || echo notok   -&gt;  类似于问号表达式，条件为真走前，假走后</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用判断条件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 两个整数比较</span><br><span class="line">    = 字符串比较</span><br><span class="line">    -lt 小 于</span><br><span class="line">    -le 小于等于</span><br><span class="line">    -eq 等 于</span><br><span class="line">    -gt 大 于</span><br><span class="line">    -ge 大于等于</span><br><span class="line">    -ne 不等于</span><br><span class="line">2. 按照文件权限进行判断</span><br><span class="line">    -r 有读的权限 [ -r 文件 ]</span><br><span class="line">    -w 有写的权限</span><br><span class="line">    -x 有执行的权限</span><br><span class="line">3. 按照文件类型进行判断</span><br><span class="line">    -f 文件存在并且是一个常规的文件</span><br><span class="line">    -e 文件存在</span><br><span class="line">    -d 文件存在并是一个目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">案例1：&quot;ok&quot;是否等于&quot;ok&quot;   -&gt;   [ &quot;ok&quot; = &quot;ok&quot; ] &amp;&amp; echo equal || echo notEqual</span><br><span class="line">案例2：23 是否大于等于 22   -&gt;   [ 23 -gt 22 ] &amp;&amp; echo yes || echo no</span><br><span class="line">案例3：/root/install.log 目录中的文件是否存在   -&gt;  [ -e /root/install.log ] &amp;&amp; echo have || echo nothave  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-10、循环和分支"><a href="#17-10、循环和分支" class="headerlink" title="17.10、循环和分支"></a>17.10、循环和分支</h2><ol>
<li><p>if 判断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br><span class="line">或者</span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">elif [条件判断式]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br><span class="line">注意事项：</span><br><span class="line">1. [ 条件判断式 ]  中括号和条件判断式之间必须有空格 </span><br><span class="line">2. 推荐使用第二种方式</span><br><span class="line"></span><br><span class="line">案例：请编写一个 shell 程序，如果输入的参数，大于等于 60，则输出 &quot;及格了&quot;，如果小于 60,则输出 &quot;不及格&quot;</span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;不及格&quot;</span><br><span class="line">fi</span><br><span class="line">输出结果：</span><br><span class="line">[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./test2.sh 60</span><br><span class="line">及格了</span><br><span class="line">[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./test2.sh 59</span><br><span class="line">不及格</span><br></pre></td></tr></table></figure>
</li>
<li><p>case 语句</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值 1&quot;）</span><br><span class="line">	如果变量的值等于值 1，则执行程序 1</span><br><span class="line">;;</span><br><span class="line">&quot;值 2&quot;）</span><br><span class="line">	如果变量的值等于值 2，则执行程序 2</span><br><span class="line">;;</span><br><span class="line">…省略其他分支…</span><br><span class="line">*）</span><br><span class="line">	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">案例1：当命令行参数是 1 时，输出 &quot;周一&quot;, 是 2 时，就输出&quot;周二&quot;， 其它情况输出 &quot;other&quot;</span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">        echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">        echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">        echo &quot;other&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 1</span><br><span class="line">周一</span><br><span class="line">[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 2</span><br><span class="line">周二</span><br><span class="line">[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 3</span><br><span class="line">other</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">第一种方式：</span><br><span class="line">for 变量 in 值1 值2 值3…</span><br><span class="line">do</span><br><span class="line">  程序</span><br><span class="line">done</span><br><span class="line">第二种方式：</span><br><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">案例1：打印命令行输入的参数 -&gt; 顺便讲解一下 $* 和 $@ 的区别</span><br><span class="line">	代码：</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">    for i in &quot;$*&quot;</span><br><span class="line">    do</span><br><span class="line">            echo &quot;the num is $i&quot;</span><br><span class="line">    done</span><br><span class="line">    echo &quot;==============&quot;</span><br><span class="line">    for j in &quot;$@&quot;</span><br><span class="line">    do</span><br><span class="line">            echo &quot;the num is $j&quot;</span><br><span class="line">    done</span><br><span class="line">	输出效果：</span><br><span class="line">	[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./for.sh 1 2 3 4 5 6</span><br><span class="line">    the num is 1 2 3 4 5 6</span><br><span class="line">    ==============</span><br><span class="line">    the num is 1</span><br><span class="line">    the num is 2</span><br><span class="line">    the num is 3</span><br><span class="line">    the num is 4</span><br><span class="line">    the num is 5</span><br><span class="line">    the num is 6</span><br><span class="line">案例2：从 1 加到 100 的值输出显示</span><br><span class="line">	代码：</span><br><span class="line">	SUM=0</span><br><span class="line">    for ((i=1;i&lt;=100;i++))</span><br><span class="line">    do</span><br><span class="line">            SUM=$[SUM+$i]</span><br><span class="line">    done</span><br><span class="line">    echo &quot;SUM=$SUM&quot;</span><br><span class="line">	输出效果：</span><br><span class="line">	SUM=5050</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 循环</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]    -&gt;  注意空格，while后面是有空格的</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br><span class="line">案例1：从命令行输入一个数 n，统计从 1+..+ n 的值</span><br><span class="line">	代码：</span><br><span class="line">	SUM=0</span><br><span class="line">    i=0</span><br><span class="line">    while [ $i -le $1 ]</span><br><span class="line">    do</span><br><span class="line">            SUM=$[$SUM+$i]</span><br><span class="line">            i=$[$i+1]</span><br><span class="line">    done    </span><br><span class="line">    echo &quot;sum=$SUM&quot;</span><br><span class="line">    输入指令：</span><br><span class="line">    ./while.sh 100</span><br><span class="line">    输出效果：</span><br><span class="line">    sum=5050</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-11、read-读取控制台输入"><a href="#17-11、read-读取控制台输入" class="headerlink" title="17.11、read 读取控制台输入"></a>17.11、read 读取控制台输入</h2><p>基本语法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">read [选项] [参数] 赋值变量名</span><br><span class="line">-p：指定读取值时的提示符，然后会阻塞等你输入一个值，回车后继续执行</span><br><span class="line">-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</span><br><span class="line">赋值变量名：会将读取到的值赋给该变量</span><br><span class="line"></span><br><span class="line">例1：读取控制台输入一个 num 值</span><br><span class="line">read -p &quot;请输入一个num值：&quot; NUM1</span><br><span class="line">echo &quot;num=$NUM1&quot;</span><br><span class="line">例2：读取控制台输入一个 num 值，在 10 秒内输入</span><br><span class="line">read -t 3 -p &quot;请输入一个num值：&quot; NUM2</span><br><span class="line">echo &quot;num2=$NUM2&quot;</span><br></pre></td></tr></table></figure>

<h2 id="17-12、函数"><a href="#17-12、函数" class="headerlink" title="17.12、函数"></a>17.12、函数</h2><ol>
<li><p>函数介绍</p>
<ul>
<li>shell 编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个：<code>basename</code>和<code>dirname</code></li>
</ul>
</li>
<li><p>系统函数</p>
<ol>
<li><p>basename  &#x3D;&gt;  返回完整路径最后 &#x2F; 的部分，常用于获取文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basename [pathname] [suffix]</span><br><span class="line"> basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来</span><br><span class="line"> suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉</span><br><span class="line"></span><br><span class="line">例子：请返回 /root/shell/read.sh 的 &quot;read.sh&quot; 部分</span><br><span class="line">    basename /root/shell/read.sh  -&gt;  返回 read.sh</span><br><span class="line">    basename /root/shell/read.sh .sh  -&gt;  如果加上后缀则只返回文件名 read</span><br></pre></td></tr></table></figure>
</li>
<li><p>dirname  &#x3D;&gt;  返回完整路径最后 &#x2F; 的前面的部分，常用于返回路径部分</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dirname 文件绝对路径 </span><br><span class="line">从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</span><br><span class="line"></span><br><span class="line">例子：请返回 /root/shell/read.sh 的 /root/shell</span><br><span class="line">dirname /root/shell/read.sh  -&gt;  返回前面的路径 /root/shell</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>自定义函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function funname()&#123;</span><br><span class="line">	Action; </span><br><span class="line">	[return int;]</span><br><span class="line">&#125;</span><br><span class="line">调用直接写函数名： funname [值]</span><br><span class="line"></span><br><span class="line">例子：计算输入两个参数的和（read）， getSum</span><br><span class="line">	代码：</span><br><span class="line">    #!/bin/bash</span><br><span class="line">    function getSum()&#123;</span><br><span class="line">            SUM=$[$n1+$n2]</span><br><span class="line">            echo &quot;和是:$SUM&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read -p &quot;请输入a:&quot; n1</span><br><span class="line">    read -p &quot;请输入b:&quot; n2</span><br><span class="line"></span><br><span class="line">    getSum $n1 $n2</span><br><span class="line">    输入指令：</span><br><span class="line">    ./fun.sh</span><br><span class="line">    输出：</span><br><span class="line">    [root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./fun.sh</span><br><span class="line">    请输入a:1</span><br><span class="line">    请输入b:2</span><br><span class="line">    和是:3</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="17-13、Shell编程综合案例"><a href="#17-13、Shell编程综合案例" class="headerlink" title="17.13、Shell编程综合案例"></a>17.13、Shell编程综合案例</h2><ul>
<li><p>需求分析：</p>
<ul>
<li>每天凌晨 2:10 备份 数据库 testDB 到 &#x2F;data&#x2F;backup&#x2F;db</li>
<li>备份开始和备份结束能够给出相应的提示信息</li>
<li>备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式，比如：2018-03-12_230201.tar.gz</li>
<li>在备份的同时，检查是否有 10 天前备份的数据库文件，如果有就将其删除。</li>
</ul>
</li>
<li><p>思路分析：</p>
<ul>
<li>数据库中有一个 testDB ，要在Linux的 &#x2F;data&#x2F;backup&#x2F;db 下备份数据库</li>
<li>现在在 &#x2F;usr&#x2F;sbin 下写一个 mysql_db_bbackup.sh 脚本来实现这个功能</li>
<li>写完脚本后交给crond来做定时任务调度</li>
</ul>
</li>
<li><p>代码实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/sbin/mysql_db_bbackup.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库的备份</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义备份的路径</span></span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前的时间，作为文件名</span></span><br><span class="line">DATETIME=$(data +%Y_%m_%d_%H%M%S)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出变量查看 以作调试</span></span><br><span class="line">echo $DATETIME</span><br><span class="line"></span><br><span class="line">echo &quot;======开始备份======&quot;</span><br><span class="line">echo &quot;======备份的路径是 $BACKUP/$DATETIME.tar.gz======&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名字</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码</span></span><br><span class="line">DB_PASSWD=root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库名</span></span><br><span class="line">DATABASE=testDB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建备份的路径  如果备份的路径文件夹存在就使用，没有就创建</span></span><br><span class="line">[ ! -d &quot;$BACKUP/$DATETIME&quot; ] &amp;&amp; mkdir -p &quot;$BACKUP/$DATETIME&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行mysql的备份数据库的指令 将备份完后的内容进行压缩，形成一个临时的压缩包文件</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PASSWD&#125; --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME/$DATETIME.sql.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包备份文件</span></span><br><span class="line">cd $BACKUP</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $DATETIME</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时目录</span></span><br><span class="line">rm -rf $BACKUP/$DATETIME</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除10天前的备份文件</span></span><br><span class="line">find $BACKUP -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;======备份成功======&quot;</span><br><span class="line"></span><br><span class="line">至此shell脚本编写完成</span><br><span class="line">然后将脚本交给crond定时执行</span><br><span class="line">crontab -e</span><br><span class="line">10 2 * * * /usr/sbin/mysql_db_bbackup.sh</span><br></pre></td></tr></table></figure></li>
</ul>

  </div>
  
</div>
          </div>
        </div>

        <link rel="stylesheet" href="/css/footer.css">
<div class="bottom-outer">
  <div class="copyright">©2022 By Zhangyj</div>
  <div class="framework-info">
    <span>Power by</span>
    <a class="a1" target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>
  </div>
</div>

          
            <!-- scripts list from theme config.yml -->
            
              <script src="/js/MiHoYo.js"></script>
              
                

  </body>

  </html>